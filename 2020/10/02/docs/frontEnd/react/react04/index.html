<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="周末翻译了两篇基础性质的文章，这篇讲 JS 中的不可变性和 immer 原文地址：https:&#x2F;&#x2F;www.smashingmagazine.com&#x2F;2020&#x2F;06&#x2F;better-reducers-with-immer&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="使用 Immer 优化 Reducer">
<meta property="og:url" content="http://example.com/2020/10/02/docs/frontEnd/react/react04/index.html">
<meta property="og:site_name" content="Hi! I am yang.">
<meta property="og:description" content="周末翻译了两篇基础性质的文章，这篇讲 JS 中的不可变性和 immer 原文地址：https:&#x2F;&#x2F;www.smashingmagazine.com&#x2F;2020&#x2F;06&#x2F;better-reducers-with-immer&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-10-02T00:00:00.000Z">
<meta property="article:modified_time" content="2021-07-27T10:26:33.580Z">
<meta property="article:tag" content="React">
<meta property="article:tag" content="Immer">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>使用 Immer 优化 Reducer</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/Mcguffen?tab=repositories">项目</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/10/09/docs/frontEnd/react/react05/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2020/09/07/docs/frontEnd/react/react03/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2020/10/02/docs/frontEnd/react/react04/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2020/10/02/docs/frontEnd/react/react04/&text=使用 Immer 优化 Reducer"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2020/10/02/docs/frontEnd/react/react04/&title=使用 Immer 优化 Reducer"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2020/10/02/docs/frontEnd/react/react04/&is_video=false&description=使用 Immer 优化 Reducer"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=使用 Immer 优化 Reducer&body=Check out this article: http://example.com/2020/10/02/docs/frontEnd/react/react04/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2020/10/02/docs/frontEnd/react/react04/&title=使用 Immer 优化 Reducer"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2020/10/02/docs/frontEnd/react/react04/&title=使用 Immer 优化 Reducer"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2020/10/02/docs/frontEnd/react/react04/&title=使用 Immer 优化 Reducer"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2020/10/02/docs/frontEnd/react/react04/&title=使用 Immer 优化 Reducer"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2020/10/02/docs/frontEnd/react/react04/&name=使用 Immer 优化 Reducer&description=&lt;p&gt;周末翻译了两篇基础性质的文章，这篇讲 JS 中的不可变性和 immer&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&#34;https://www.smashingmagazine.com/2020/06/better-reducers-with-immer/&#34;&gt;https://www.smashingmagazine.com/2020/06/better-reducers-with-immer/&lt;/a&gt;&lt;/p&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2020/10/02/docs/frontEnd/react/react04/&t=使用 Immer 优化 Reducer"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7%E5%8F%8A%E5%85%B6%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">JavaScript 的不可变性及其重要性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Immer-%E4%B8%AD%E7%9A%84-produce-%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">Immer 中的 produce 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Immer-%E4%B9%A6%E5%86%99-Reducers"><span class="toc-number">3.</span> <span class="toc-text">使用 Immer 书写 Reducers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-useImmer-%E5%92%8C-useImmerReducer-%E9%92%A9%E5%AD%90"><span class="toc-number">4.</span> <span class="toc-text">使用 useImmer 和 useImmerReducer 钩子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8-Immer"><span class="toc-number">5.</span> <span class="toc-text">为什么你应该使用 Immer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">6.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB"><span class="toc-number">7.</span> <span class="toc-text">相关阅读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%AA%E5%A4%96%EF%BC%9AImmer-js-%E7%B2%BE%E8%AF%BB"><span class="toc-number">8.</span> <span class="toc-text">番外：Immer.js 精读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Immer-js-%E7%B2%BE%E8%AF%BB"><span class="toc-number">8.1.</span> <span class="toc-text">Immer.js 精读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86"><span class="toc-number">8.2.</span> <span class="toc-text">生成代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getter"><span class="toc-number">8.3.</span> <span class="toc-text">getter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setter"><span class="toc-number">8.4.</span> <span class="toc-text">setter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90-Immutable-%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.5.</span> <span class="toc-text">生成 Immutable 对象</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        使用 Immer 优化 Reducer
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name"></span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-10-02T00:00:00.000Z" itemprop="datePublished">2020-10-02</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/frontEnd/">frontEnd</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Immer/" rel="tag">Immer</a>, <a class="tag-link-link" href="/tags/React/" rel="tag">React</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>周末翻译了两篇基础性质的文章，这篇讲 JS 中的不可变性和 immer</p>
<p>原文地址：<a target="_blank" rel="noopener" href="https://www.smashingmagazine.com/2020/06/better-reducers-with-immer/">https://www.smashingmagazine.com/2020/06/better-reducers-with-immer/</a></p>
<span id="more"></span>

<blockquote>
<p>速览：在本文中，我们将学习如何使用 Immer 书写 reducers。在使用 React 时我们经常会维护大量的 state，同时为更新 state 需要创建很多 reducers。在组件状态 state 的每一个地方手动编写 reducer 会导致代码膨胀，这很容易导致代码出错。本文将告诉你，Immer 如何将编写 state reducers 的过程变得更简单。</p>
</blockquote>
<p>作为 React 开发者，你应该对这条原则很熟悉：state 数据不应该是可变的，你可能会想这是什么意思（很多人开始时都会对此感到困惑）。</p>
<p>本文将解释这一切：你将明白什么是不可变数据，为什么需要不可变数据；如何使用 Immer 去处理不可变数据和使用 Immer 的好处。</p>
<p>你可以在这个仓库找到本文的示例代码：<a target="_blank" rel="noopener" href="https://github.com/chidimo/immutability-in-js">repo</a>。</p>
<h2 id="JavaScript-的不可变性及其重要性"><a href="#JavaScript-的不可变性及其重要性" class="headerlink" title="JavaScript 的不可变性及其重要性"></a>JavaScript 的不可变性及其重要性</h2><p>Immer.js 是由 Michel Weststrate 编写的一个轻量级 JavaScript 库，其目标是允许你「以更方便地方式处理不可变状态」。但是在开始进入 Immer 之前，让我们快速重温一下 JavaScript 中的不变性及其在 React 项目中的重要性。</p>
<p>最新的 ECMAScript（aka JavaScript）标准定义了九种内置数据类型，在这九种类型中，有六种被称为原始值/类型。这六种是 <code>undefined</code>/<code>number</code>/<code>string</code>/<code>boolean</code>/<code>bigint</code>/<code>symbol</code>。通过对 JavaScript 的 <code>typeof</code> 运算符进行简单检查，即可了解这些数据所对应的数据类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">5</span>) <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;name&#x27;</span>) <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (<span class="number">1</span> &lt; <span class="number">2</span>)) <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">&#x27;js&#x27;</span>)) <span class="comment">// symbol</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">BigInt</span>(<span class="number">900719925474</span>)) <span class="comment">// bigint</span></span><br></pre></td></tr></table></figure>

<p>一个 <code>primitive</code> 原始值/类型是一个不是对象且没有方法的值，对于当前讨论最重要的是，原始类型值 <code>primitive</code> 一旦创建就无法更改。因此，原始类型值 <code>primitive</code> 是不可改变的。</p>
<p>其余的三种类型为 <code>null</code>/<code>object</code>/<code>function</code>，用 <code>typeof</code> 检查一下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>) <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> [<span class="number">0</span>, <span class="number">1</span>]) <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;<span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>&#125;) <span class="comment">// object</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function">() =&gt;</span> (&#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f) <span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<p>这些类型是可变的，这意味着它们的值可以在创建之后随时更改。</p>
<p>你可能想知道为什么我有数组 <code>[0, 1]</code>，在 JavaScript 世界中，数组知识对象的一种特殊类型。如果你还想知道 <code>null</code> 和 <code>undefined</code> 有什么不同，<code>undefined</code> 指我们没有给变量设置值，而 <code>null</code> 是对象的特殊情况，如果你知道某个对象应该是一个对象但是这个对象并不存在，则只需要返回 <code>null</code>。（译者：它们大多数情况是可以相互替代的，一些开发者不用 <code>null</code> 只使用 <code>undefined</code> 以降低类型复杂度）</p>
<p>为了举例说明，可以在浏览器控制台中运行以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;aeiou&#x27;</span>.match(<span class="regexp">/[x]/gi</span>)) <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;xyzabc&#x27;</span>.match(<span class="regexp">/[x]/gi</span>)) <span class="comment">// [ &#x27;x&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p><code>String.prototype.match</code> 应该返回一个数组，这是一个对象类型。如果找不到此类对象，则返回 <code>null</code>，返回 <code>undefined</code> 在这里也没有意义。</p>
<p>够了，让我们把话题回到不可变性。</p>
<p>根据 MDN 文档：</p>
<blockquote>
<p>“除对象以外的所有类型都定义了不可变的值（即不能更改的值）。”</p>
<p><em>“All types except objects define immutable values (that is, values which can’t be changed).”</em></p>
</blockquote>
<p>该语句包含了函数，因为它们是 JavaScript 对象的一种特殊类型，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/Function">参考函数定义</a>。</p>
<p>让我们快速了解一下可变和不可变数据类型在实际中的含义。尝试在控制台运行以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`a: <span class="subst">$&#123;a&#125;</span>; b: <span class="subst">$&#123;b&#125;</span>`</span>) <span class="comment">// a: 5; b: 5</span></span><br><span class="line">b = <span class="number">7</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`a: <span class="subst">$&#123;a&#125;</span>; b: <span class="subst">$&#123;b&#125;</span>`</span>) <span class="comment">// a: 5; b: 7</span></span><br></pre></td></tr></table></figure>

<p>结果显示，即使 <code>b</code> 是从 <code>a</code> 派生出来的，更改 <code>b</code> 的值也不会影响 <code>a</code> 的值。这是由于 JavaScript 引擎执行语句 <code>b = a</code> 时，它会创建一个新的单独的内存位置，在其中放置 5，然后将 <code>b</code> 指向该位置。</p>
<p>那对象呢？参考以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = &#123; <span class="attr">name</span>: <span class="string">&#x27;some name&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> d = c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`c: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(c)&#125;</span>; d: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(d)&#125;</span>`</span>) </span><br><span class="line"><span class="comment">// &#123;&quot;name&quot;:&quot;some name&quot;&#125;; d: &#123;&quot;name&quot;:&quot;some name&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">d.name = <span class="string">&#x27;new name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`c: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(c)&#125;</span>; d: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(d)&#125;</span>`</span>) </span><br><span class="line"><span class="comment">// &#123;&quot;name&quot;:&quot;new name&quot;&#125;; d: &#123;&quot;name&quot;:&quot;new name&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到，通过变量 <code>d</code> 更改 <code>name</code> 属性也会在 <code>c</code> 中更改它。这是由于 JavaScript 引擎执行语句 <code>c = &#123; name: &#39;some name&#39; &#125;</code> 时，会在内存中创建一个空间，将对象放在其中，并指向 c。然后，执行 <code>d = c</code> 时，JavaScript 引擎仅仅将 <code>d</code> 指向相同的位置，它不会创建新的存储位置。因此，对 <code>d</code> 中项目的任何更改都暗含了对 <code>c</code> 中项目的操作。很清晰，我们就能明白这会造成什么样的麻烦。</p>
<p>假设你正在开发一个 React 应用程序，并且想在某个地方通过读取变量 <code>c</code> 将用户名显示为某些名称。但是在其他地方存在对 <code>c</code> 的引用 <code>d</code>，这引入了错误，这会导致使用者的命名看上去是新的命名。如果 <code>c</code> 和 <code>d</code> 是基本数据类型，就不会有这个问题，但是对于 React 而言，仅使用基本数据类型是不够的。</p>
<p>这是应该重视在应用中保持状态不可变的主要原因，我鼓励你通过阅读 Immutable.js 文档中的一小节来了解其它一些注意事项：<a target="_blank" rel="noopener" href="https://github.com/immutable-js/immutable-js/#the-case-for-immutability">the case for immutability</a>。</p>
<p>了解了为什么我们需要在 React 应用中实现数据不可变性之后，现在让我们看一下 Immer 如何通过 <code>produce</code> 函数解决问题。</p>
<h2 id="Immer-中的-produce-函数"><a href="#Immer-中的-produce-函数" class="headerlink" title="Immer 中的 produce 函数"></a>Immer 中的 <code>produce</code> 函数</h2><p>Immer 的核心 API 很小，你要使用的主要功能就是 <code>produce</code> 函数，<code>produce</code> 只需要一个初始状态和一个回调函数，该回调函数定义了如何处理状态。回调函数本身会受到对其所有预期更新的状态的 <code>draft</code>（相同，但是仍然是副本）（译者：草稿，可以理解为数据代理）。最后，在应用所有更改结束后，将产生一个新的、不可变的状态。（译者：类似于深拷贝数据，但有所不同）</p>
<p>这种状态更新的一般模式是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// produce signature</span></span><br><span class="line">produce(state, callback) =&gt; nextState</span><br></pre></td></tr></table></figure>

<p>让我们来看它在实际编码中怎么运用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> produce <span class="keyword">from</span> <span class="string">&#x27;immer&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">  pets: [<span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>],</span><br><span class="line">  packages: [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;react&#x27;</span>, <span class="attr">installed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;redux&#x27;</span>, <span class="attr">installed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to add a new package</span></span><br><span class="line"><span class="keyword">const</span> newPackage = &#123; <span class="attr">name</span>: <span class="string">&#x27;immer&#x27;</span>, <span class="attr">installed</span>: <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextState = produce(initState, <span class="function"><span class="params">draft</span> =&gt;</span> &#123;</span><br><span class="line">  draft.packages.push(newPackage)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们只是传递了起始状态和一个回调函数，该回调指定了我们期望突变（mutation）发生的处理方式：<code>draft.packages.push(newPackage)</code>。就是这么简单，不需要接触这个状态对象的其它任何地方，它使 <code>initState</code> 保持不变，并且在结构上共享了我们在开始状态和新状态之间没有接触到的状态。在这个例子中指的就是 <code>pets</code> 数组属性，产生的 <code>nextState</code> 是一颗不可变的状态树，其中包含我们所做的更改以及未修改的部分。</p>
<p>掌握了这些简单但是有用的知识之后，我们来看 <code>produce</code> 如何帮助我们简化 React 的 <code>reducers</code>。</p>
<h2 id="使用-Immer-书写-Reducers"><a href="#使用-Immer-书写-Reducers" class="headerlink" title="使用 Immer 书写 Reducers"></a>使用 Immer 书写 Reducers</h2><p>假设我们有如下定义的状态对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">  pets: [<span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>],</span><br><span class="line">  packages: [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;react&#x27;</span>, <span class="attr">installed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;redux&#x27;</span>, <span class="attr">installed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们想要添加一个新对象，并且将 <code>installed</code> 属性设置为 <code>true</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newPackage = &#123; <span class="attr">name</span>: <span class="string">&#x27;immer&#x27;</span>, <span class="attr">installed</span>: <span class="literal">false</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>如果我们要使用 <code>JavaScript</code> 对象和数组扩展语法进行常规操作，则 reducer 可能会这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> updateReducer = <span class="function">(<span class="params">state = initState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ADD_PACKAGE&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        packages: [...state.packages, action.package],</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;UPDATE_INSTALLED&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        packages: state.packages.map(<span class="function"><span class="params">pack</span> =&gt;</span></span><br><span class="line">          pack.name === action.name</span><br><span class="line">            ? &#123; ...pack, <span class="attr">installed</span>: action.installed &#125;</span><br><span class="line">            : pack</span><br><span class="line">        ),</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们能看到，对于这个相对简单的状态对象而言，<code>...state</code> 这是不必要的冗余代码并且容易出错，我们没必要考虑对象的每一个属性，让我们看看 <code>immer</code> 如何简化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> updateReducerWithProduce = <span class="function">(<span class="params">state = initState, action</span>) =&gt;</span></span><br><span class="line">  produce(state, <span class="function"><span class="params">draft</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ADD_PACKAGE&#x27;</span>:</span><br><span class="line">      draft.packages.push(action.package);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;UPDATE_INSTALLED&#x27;</span>: &#123;</span><br><span class="line">      <span class="keyword">const</span> package = draft.packages.filter(<span class="function"><span class="params">p</span> =&gt;</span> p.name === action.name)[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">if</span> (package) package.installed = action.installed;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>通过几行代码大大简化了 <code>reducer</code>，同样，如果我们进入了默认情况，<code>immer</code> 只会返回 <code>draft</code> 状态，并不执行任何操作。注意它是如何实现减少样板代码和状态扩散的，有了 Immer，我们只关心我们需要的状态部分。如果找不到这样一个操作，（比如在 <code>UPDATE_INSTALLED</code>  操作中），将跳过操作，没有多余的执行。<code>produce</code>函数也很方便用于柯里化，将回调函数作为 <code>produce</code> 的第一个参数便能实现柯里化。柯里化 <code>produce</code> 的代码结构如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//curried produce signature</span></span><br><span class="line">produce(callback) =&gt; <span class="function">(<span class="params">state</span>) =&gt;</span> nextState</span><br></pre></td></tr></table></figure>

<p>让我们看一下，如何使用柯里化后的 <code>produce</code> 来组织之前的 <code>state</code>，像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curriedProduce = produce(<span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;ADD_PACKAGE&#x27;</span>:</span><br><span class="line">    draft.packages.push(action.package);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;SET_INSTALLED&#x27;</span>: &#123;</span><br><span class="line">    <span class="keyword">const</span> package = draft.packages.filter(<span class="function"><span class="params">p</span> =&gt;</span> p.name === action.name)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (package) package.installed = action.installed;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>柯里化的 <code>produce</code> 函数接受一个函数作为第一个参数，并返回一个柯里化的 <code>produce</code>，该柯里化 <code>produce</code> 仅需要一个状态，从而去生产处理后的状态。该函数的第一个参数是草稿状态（<code>draft state</code>，当调用这个柯里化 <code>produce</code> 函数并将状态 <code>state</code> 传递进去时产生）。接下来跟随我们希望传给该函数的每一个参数。我们现在要用这个函数做的，是传递状态和对应的数据处理操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a new package to the starting state</span></span><br><span class="line"><span class="keyword">const</span> nextState = curriedProduce(initState, &#123;</span><br><span class="line">  type: <span class="string">&#x27;ADD_PACKAGE&#x27;</span>,</span><br><span class="line">  package: newPackage,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// update an item in the recently produced state</span></span><br><span class="line"><span class="keyword">const</span> nextState2 = curriedProduce(nextState, &#123;</span><br><span class="line">  type: <span class="string">&#x27;SET_INSTALLED&#x27;</span>,</span><br><span class="line">  name: <span class="string">&#x27;immer&#x27;</span>,</span><br><span class="line">  installed: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注意，在 React 应用中使用 <code>useReducer</code> 时，我们不需要像上面所做的那样，显示地传递状态，因为 <code>useReducer</code> 本身可以处理这样的问题。</p>
<p>你可能会想知道，<code>immer</code> 是否会像最近 <code>React</code> 中的 <code>hooks</code> 一样吸引人？好吧，<code>immer</code> 也提供两个用于处理状态的钩子：<code>useImmer</code> 和 <code>useImmerReducer</code>，让我们看看它们是如何生效的。</p>
<h2 id="使用-useImmer-和-useImmerReducer-钩子"><a href="#使用-useImmer-和-useImmerReducer-钩子" class="headerlink" title="使用 useImmer 和 useImmerReducer 钩子"></a>使用 useImmer 和 useImmerReducer 钩子</h2><p>关于 <code>useImmer</code> 的最好描述可以从 <code>use-immer</code> 项目中的 <code>README</code> 中找到：</p>
<blockquote>
<p><code>useImmer(initialState)</code> 和 <code>useState</code> 很相像，这个方法返回一个元祖（<code>tuple</code>），元祖的第一个值是当前状态，第二个值是更新函数，它接受一个 <a target="_blank" rel="noopener" href="https://github.com/mweststrate/immer#api">immer producer function</a>，在函数中 <code>draft</code> 状态可以自由更改，直到 <code>producer</code> 结束，这个变更后的数据是不可变的，并且可以作为下一次的状态。</p>
<p><code>useImmer(initialState)</code> <em>is very similar to</em> <a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-state.html"><code>useState</code></a><em>. The function returns a tuple, the first value of the tuple is the current state, the second is the updater function, which accepts an</em> <a target="_blank" rel="noopener" href="https://github.com/mweststrate/immer#api">immer producer function</a><em>, in which the</em> <code>draft</code> <em>can be mutated freely, until the producer ends and the changes will be made immutable and become the next state.</em></p>
</blockquote>
<p>要使用这些 <code>hooks</code>，除了必要的 <code>immer</code> 库之外，还需要单独安装它们：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add immer use-immer</span><br><span class="line"></span><br><span class="line">npm i immer use-immer</span><br></pre></td></tr></table></figure>

<p>在代码中，<code>useImmer</code> 会像这样使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useImmer &#125; <span class="keyword">from</span> <span class="string">&quot;use-immer&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initState = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> [ data, updateData ] = useImmer(initState)</span><br></pre></td></tr></table></figure>

<p>就是这么简单，你可以说这是 React 的 <code>useState</code> 带着一下升级。使用状态函数 <code>updateData</code> 很简单，它接受到 <code>draft</code> 状态，你可以根据自身需要随便更改：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make changes to data</span></span><br><span class="line">updateData(<span class="function"><span class="params">draft</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// modify the draft as much as you want.</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p> <code>Immer</code> 的创建者提供了一个 <a target="_blank" rel="noopener" href="https://codesandbox.io/s/l97yrzw8ol">codesandbox</a> 例子，你可以尝试运行。</p>
<p>如果你使用过 React 的 <code>useReducer</code> 钩子，那么 <code>useImmerReducer</code> 同样简单易用，它具有相似的签名，让我们来看看代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useImmerReducer &#125; <span class="keyword">from</span> <span class="string">&quot;use-immer&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initState = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;      </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [data, dataDispatch] = useImmerReducer(reducer, initState);</span><br></pre></td></tr></table></figure>

<p>我们可以看到，<code>reducer</code> 收到了 <code>draft</code> 状态，我们可以根据需要进行处理，这里也有一个 <a target="_blank" rel="noopener" href="https://codesandbox.io/s/2zor1monvp">codesandbox</a> 例子供你体验。</p>
<p>这就是使用 <code>immer</code> 的简单之处，如果你仍想知道在项目中使用 <code>immer</code> 的具体原因，下面是使用 <code>immer</code> 的一些重要因素。</p>
<h2 id="为什么你应该使用-Immer"><a href="#为什么你应该使用-Immer" class="headerlink" title="为什么你应该使用 Immer"></a>为什么你应该使用 Immer</h2><p>如果你编写状态管理逻辑已经有一段时间，那么你将很快体会到 <code>immer</code> 提供的简便性。但这并不是 <code>immer</code> 提供的唯一好处。</p>
<p>当你使用 <code>immer</code> 时，最终会减少书写样板代码的次数，就像我们通过对相对简单 <code>reducer</code> 进行的处理那样。同时也会让层级较深情况下的数据更新变得容易。 </p>
<p>在使用 <a target="_blank" rel="noopener" href="https://github.com/immutable-js/immutable-js/">Immutable.js</a> 之类的库时，你必须学习新的 <code>API</code> 才能获得数据不变性的好处，但是使用 <code>immer</code>，你可以使用普通的 JavaScript <code>Objects</code>、<code>Arrays</code>、<code>Sets</code> 和 <code>Maps</code>。这没有新的学习成本。</p>
<p><code>immer</code> 默认还提供结构共享，这仅意味着，当你对状态对象进行变更时，<code>immer</code> 会在新状态和之前状态之间自动共享状态的未变更部分。</p>
<p>使用 <code>immer</code>，你还可以自动冻结对象，这意味着你无法更改被 <code>produce</code> 的状态。例如，当我开始使用 <code>immer</code> 的时候，我尝试将 <code>sort</code> 方法用于 <code>immer</code> 的 <code>produce</code> 函数返回的对象数组。这将发生错误，告知我无法对 <code>array</code> 进行更改。我必须在进行排序操作之前进行 <code>array</code> 切片操作。再说一遍，生产出的 <code>nextState</code> 是不可变状态树。</p>
<p><code>immer</code> 的类型检查也很强，同时压缩后只有 3KB，十分轻量。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>当管理状态更新时，使用 <code>immer</code> 对我们来说是不费吹灰之力的。这是一个很轻巧的库，可以让你继续使用所学的关于 JavaScript 的所有知识，而不会产生额外的学习成本。我鼓励你将其安装在项目中并立即运用它，你可以在现有项目中添加使用它，并逐步改造你的 <code>reducer</code>。</p>
<p>推荐去阅读 <a target="_blank" rel="noopener" href="https://medium.com/hackernoon/introducing-immer-immutability-the-easy-way-9d73d8f71cb3">Immer introductory blog post</a> by Michael Weststrate。我发现特别有趣的部分是 “Immer 如何工作？”章节，这章解释了 Immer 如何利用 JS 自身的功能如代理 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/nl/docs/Web/JavaScript/Reference/Global_Objects/Proxy">proxies</a> 和概念 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Copy-on-write">copy-on-write</a>。</p>
<p>推荐阅读此博客文章：<a target="_blank" rel="noopener" href="https://desalasworks.com/article/immutability-in-javascript-a-contrarian-view/">Immutability in JavaScript: A Contratian View</a>，文章作者 Steven de Salas 介绍了他关于追求不可变性的思想。</p>
<p>希望你通过这篇文章中学到的知识立即体验 Imemr。</p>
<h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/immerjs/use-immer"><code>use-immer</code></a>, GitHub</li>
<li><a target="_blank" rel="noopener" href="https://github.com/immerjs/immer">Immer</a>, GitHub</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/Function"><code>function</code></a>, MDN web docs, Mozilla</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/nl/docs/Web/JavaScript/Reference/Global_Objects/Proxy"><code>proxy</code></a>, MDN web docs, Mozilla</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object_(computer_science)">Object (computer science)</a>, Wikipedia</li>
<li>“<a target="_blank" rel="noopener" href="https://github.com/chidimo/immutability-in-js">Immutability in JS</a>,” Orji Chidi Matthew, GitHub</li>
<li>“<a target="_blank" rel="noopener" href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">ECMAScript Data Types and Values</a>,” Ecma International</li>
<li><a target="_blank" rel="noopener" href="https://github.com/immutable-js/immutable-js/">Immutable collections for JavaScript</a>, Immutable.js , GitHub</li>
<li>“<a target="_blank" rel="noopener" href="https://github.com/immutable-js/immutable-js/#the-case-for-immutability">The case for Immutability</a>,” Immutable.js , GitHub</li>
</ol>
<h2 id="番外：Immer-js-精读"><a href="#番外：Immer-js-精读" class="headerlink" title="番外：Immer.js 精读"></a>番外：Immer.js 精读</h2><p>来自知乎同名文章</p>
<h3 id="Immer-js-精读"><a href="#Immer-js-精读" class="headerlink" title="Immer.js 精读"></a>Immer.js 精读</h3><p><code>Immer</code> 是更底层的拼图，它可以插入到任何数据流框架作为功能增强，不得不感叹 Mweststrate 真的非常高瞻远瞩</p>
<p><code>Immer</code> 是一个支持柯里化，<strong>仅支持同步计算的工具</strong>，所以非常适合作为 <code>redux</code> 的 <code>reducer</code> 使用</p>
<blockquote>
<p>Immer 也支持直接 return value，这个功能比较简单，所以此功能跳过不谈</p>
<p>PS: mutable 与 return 不能同时返回不同对象，否则弄不清楚到哪种修改是有效的</p>
</blockquote>
<p>柯里化详情自行查看 <a target="_blank" rel="noopener" href="https://github.com/dominictarr/curry">curry</a>，我们来看 <code>produce</code> 函数的 <code>callback</code> 部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">produce(obj, (draft) &#x3D;&gt; &#123;</span><br><span class="line">  draft.count++</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>obj</code> 是个普通对象，那么黑魔法一定出现在 <code>draft</code> 对象，<code>Immer</code> 给 <code>draft</code> 对象的所有属性做了监听</p>
<p>所以整体思路就有了：<code>draft</code> 是 <code>obj</code> 的代理，对 <code>draft</code> mutable 的修改都会流入到自定义 <code>setter</code> 函数，它并不修改原始对象的值，而是递归父级不断浅拷贝，最终返回新的顶层对象，作为 <code>produce</code> 函数的返回值</p>
<h3 id="生成代理"><a href="#生成代理" class="headerlink" title="生成代理"></a>生成代理</h3><p>第一步，也就是将 <code>obj</code> 转为 <code>draft</code> 这一步，为了提高 <code>Immutable</code> 的运行效率，需要一些额外信息，因此将 <code>obj</code> 封装成一个包含额外信息的代理对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	modified, &#x2F;&#x2F; 是否被修改过</span><br><span class="line">  finalized, &#x2F;&#x2F; 是否已经完成（所有 setter 完成，并且已经生成了 copy）</span><br><span class="line">  parent, &#x2F;&#x2F; 父级对象</span><br><span class="line">  base, &#x2F;&#x2F; 原始对象</span><br><span class="line">  copy, &#x2F;&#x2F; base（也就是 obj）的浅拷贝，使用 Object.assign(Object.create(null), obj)实现</span><br><span class="line">  proxies, &#x2F;&#x2F; 存储每个 propertyKey 的代理对象，采用懒初始化策略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个代理对象上，绑定了自定义 <code>getter</code>、<code>setter</code>，然后直接将其扔给 <code>produce</code> 执行</p>
<h3 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">produce&#96; 回调函数中包含了用户的 &#96;mutable&#96; 代码，所以现在入口变成了 &#96;getter&#96; 与 &#96;setter</span><br></pre></td></tr></table></figure>

<p><code>getter</code> 主要用来懒初始化代理对象，也就是当代理对象子属性被访问的时候，才会生成其代理对象</p>
<p>这么说比较抽象，我们举个 🌰 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	a: &#123;&#125;,</span><br><span class="line">	b: &#123;&#125;,</span><br><span class="line">	c: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么初始情况下，<code>draft</code> 是 <code>obj</code> 的代理，所以访问 <code>draft.a</code>、<code>draft.b</code>、<code>draft.c</code> 时，都能触发 <code>getter</code>、<code>setter</code>，进入自定义处理逻辑，可是对 <code>draft.a.x</code> 相当于访问了 <code>draftA.x</code>，所以能递归监听一个对象的所有属性</p>
<p>同时，如果代码中只访问了 <code>draft.a</code>，那么只会在内存生成 <code>draftA</code> 代理，<code>b</code> <code>c</code> 属性因为没有访问，因此不需要浪费资源生成代理 <code>draftB</code>、<code>draftC</code></p>
<p>当然 Immer 做了一些性能优化，以及在对象被修改过（<code>modified</code>）获取其 <code>copy</code> 对象，为了保证 <code>base</code> 是不可变的，这里不做展开</p>
<h3 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h3><p>当对 <code>draft</code> 修改时，会对 <code>base</code> 也就是原始值进行浅拷贝，保存到 <code>copy</code> 属性，同时将 <code>modified</code> 属性设置为 <code>true</code>。这样就完成了最重要的 <code>Immutable</code> 过程，而且浅拷贝并不是很消耗性能，加上是按需浅拷贝，因此 <code>Immer</code> 的性能还可以</p>
<p>同时为了保证整条链路的对象都是新对象，会根据 <code>parent</code> 属性递归父级，不断浅拷贝，直到这个叶子节点到根节点整条链路对象都换新为止</p>
<h3 id="生成-Immutable-对象"><a href="#生成-Immutable-对象" class="headerlink" title="生成 Immutable 对象"></a>生成 Immutable 对象</h3><p>当执行完 <code>produce</code> 后，用户的所有修改已经完成（所以 <code>Immer</code> 没有支持异步），如果 <code>modified</code> 属性为 <code>false</code> ，说明用户根本没有更改这个对象，那直接返回原始 <code>base</code> 属性即可</p>
<p>如果 <code>modified</code> 属性为 <code>true</code>，说明对象发生了改变，返回 <code>copy</code> 属性即可。但是 <code>setter</code> 过程是递归的，<code>draft</code> 的子对象也是 <code>draft</code>（包含了 <code>base</code>、<code>copy</code>、<code>modified</code> 等额外属性的代理），我们必须一层层递归，拿到真正的值</p>
<p>所以在这个阶段，所有 <code>draft</code> 的 <code>finalized</code> 都是 <code>false</code>、<code>copy</code> 内部可能还存在大量 <code>draft</code> 属性，因此递归 <code>base</code> 与 <code>copy</code> 的子属性，如果相同，就直接返回；如果不同，递归一次整个过程</p>
<p>最后返回的对象是由 <code>base</code> 的一些属性（没有修改的部分）和 <code>copy</code> 的一些属性（修改的部分）最终拼接而成的。最后使用 <code>freeze</code> 冻结 <code>copy</code> 属性，将 <code>finalized</code> 属性设置为 <code>true</code></p>
<p>至此，返回值生成完毕，我们将最终值保存在 <code>copy</code> 属性上，并将其冻结，返回了 <code>Immutable</code> 的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Immer&#96; 因此完成了不可思议的操作：&#96;Create the next immutable state by mutating the current one</span><br></pre></td></tr></table></figure>

<blockquote>
<p>源码读到这里，发现 Immer 其实可以支持异步，只要支持 produce 函数返回 Promise 即可。最大的问题是，最后对代理的 <code>revoke</code> 清洗，需要借助全局变量，这一点阻碍了 Immer 对异步的支持。</p>
</blockquote>

  </div>
  <div>
    <a href="https://github.com/Mcguffen/mcguffen.github.io/edit/myblog/source/_posts/docs/frontEnd/react/react04.md"target="_blank">编辑</a>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/Mcguffen?tab=repositories">项目</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7%E5%8F%8A%E5%85%B6%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">JavaScript 的不可变性及其重要性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Immer-%E4%B8%AD%E7%9A%84-produce-%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">Immer 中的 produce 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Immer-%E4%B9%A6%E5%86%99-Reducers"><span class="toc-number">3.</span> <span class="toc-text">使用 Immer 书写 Reducers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-useImmer-%E5%92%8C-useImmerReducer-%E9%92%A9%E5%AD%90"><span class="toc-number">4.</span> <span class="toc-text">使用 useImmer 和 useImmerReducer 钩子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8-Immer"><span class="toc-number">5.</span> <span class="toc-text">为什么你应该使用 Immer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">6.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB"><span class="toc-number">7.</span> <span class="toc-text">相关阅读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%AA%E5%A4%96%EF%BC%9AImmer-js-%E7%B2%BE%E8%AF%BB"><span class="toc-number">8.</span> <span class="toc-text">番外：Immer.js 精读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Immer-js-%E7%B2%BE%E8%AF%BB"><span class="toc-number">8.1.</span> <span class="toc-text">Immer.js 精读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86"><span class="toc-number">8.2.</span> <span class="toc-text">生成代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getter"><span class="toc-number">8.3.</span> <span class="toc-text">getter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setter"><span class="toc-number">8.4.</span> <span class="toc-text">setter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90-Immutable-%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.5.</span> <span class="toc-text">生成 Immutable 对象</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2020/10/02/docs/frontEnd/react/react04/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2020/10/02/docs/frontEnd/react/react04/&text=使用 Immer 优化 Reducer"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2020/10/02/docs/frontEnd/react/react04/&title=使用 Immer 优化 Reducer"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2020/10/02/docs/frontEnd/react/react04/&is_video=false&description=使用 Immer 优化 Reducer"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=使用 Immer 优化 Reducer&body=Check out this article: http://example.com/2020/10/02/docs/frontEnd/react/react04/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2020/10/02/docs/frontEnd/react/react04/&title=使用 Immer 优化 Reducer"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2020/10/02/docs/frontEnd/react/react04/&title=使用 Immer 优化 Reducer"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2020/10/02/docs/frontEnd/react/react04/&title=使用 Immer 优化 Reducer"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2020/10/02/docs/frontEnd/react/react04/&title=使用 Immer 优化 Reducer"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2020/10/02/docs/frontEnd/react/react04/&name=使用 Immer 优化 Reducer&description=&lt;p&gt;周末翻译了两篇基础性质的文章，这篇讲 JS 中的不可变性和 immer&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&#34;https://www.smashingmagazine.com/2020/06/better-reducers-with-immer/&#34;&gt;https://www.smashingmagazine.com/2020/06/better-reducers-with-immer/&lt;/a&gt;&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2020/10/02/docs/frontEnd/react/react04/&t=使用 Immer 优化 Reducer"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2021
    Hi! I am yang.
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/Mcguffen?tab=repositories">项目</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
