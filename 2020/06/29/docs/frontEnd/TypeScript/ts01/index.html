<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="JS 是一门动态弱类型语言，与之对应，自然有静态类型语言和强类型语言。如何区分它们，是在学习一门计算机语言之前首先要搞清楚的问题，理解了这些概念，你就会明白为什么有语言鄙视链，也会对 TS 的诞生的原因有一定的认识。">
<meta property="og:type" content="article">
<meta property="og:title" content="TypeScript 整理手册">
<meta property="og:url" content="http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/index.html">
<meta property="og:site_name" content="Hi! I am yang.">
<meta property="og:description" content="JS 是一门动态弱类型语言，与之对应，自然有静态类型语言和强类型语言。如何区分它们，是在学习一门计算机语言之前首先要搞清楚的问题，理解了这些概念，你就会明白为什么有语言鄙视链，也会对 TS 的诞生的原因有一定的认识。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg8y5jkwumj30lr07340e.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg8y836cn8j30lw09tmyo.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg8ya27rofj30e7095ta6.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg8ydimjv6j30ib09qq3k.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg8yqf0aayj305i01hmx3.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg8z4d2u3wj31f508wgnd.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg913pdv9lj30b200ndfs.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg913ugnt8j30ne01tmxi.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg915mnf51j309503pq2w.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg91cgjgcbj30hw06n3zn.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg8ymh7rkxj30gg09zgmi.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg92gtghkrj30ke068405.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg92hwlsmej30dj03uaam.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg97qcnzchj30h706jq3i.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg97v44mqij30dn05k3z5.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg97vzcrufj30dv06twfp.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg97wkfb5cj30ih05et9k.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg97x9nkvrj309d057aaj.jpg">
<meta property="article:published_time" content="2020-06-29T00:00:00.000Z">
<meta property="article:modified_time" content="2021-07-27T10:25:15.888Z">
<meta property="article:tag" content="TypeScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg8y5jkwumj30lr07340e.jpg">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>TypeScript 整理手册</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/Mcguffen?tab=repositories">项目</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/06/30/docs/frontEnd/react/react01/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2020/06/24/docs/development/agile/README/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/&text=TypeScript 整理手册"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/&title=TypeScript 整理手册"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/&is_video=false&description=TypeScript 整理手册"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=TypeScript 整理手册&body=Check out this article: http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/&title=TypeScript 整理手册"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/&title=TypeScript 整理手册"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/&title=TypeScript 整理手册"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/&title=TypeScript 整理手册"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/&name=TypeScript 整理手册&description=&lt;p&gt;JS 是一门动态弱类型语言，与之对应，自然有静态类型语言和强类型语言。如何区分它们，是在学习一门计算机语言之前首先要搞清楚的问题，理解了这些概念，你就会明白为什么有语言鄙视链，也会对 TS 的诞生的原因有一定的认识。&lt;/p&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/&t=TypeScript 整理手册"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">类型基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%B1%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">强类型语言与弱类型语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是强类型语言？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%B1%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">什么是弱类型语言？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.1.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">1.2.</span> <span class="toc-text">静态类型语言与动态类型语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaScript-%E4%B8%8E-C-%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.1.</span> <span class="toc-text">JavaScript 与 C++ 对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.2.</span> <span class="toc-text">对比总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">其他定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">1.3.</span> <span class="toc-text">小结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B%E8%B1%A1%E9%99%90"><span class="toc-number">1.3.1.</span> <span class="toc-text">语言类型象限</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-TypeScript-%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.1.</span> <span class="toc-text">创建 TypeScript 项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7"><span class="toc-number">2.1.1.</span> <span class="toc-text">配置构建工具</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-webpack-base-config-js"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">公共环境配置 webpack.base.config.js</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-webpack-dev-config-js"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">开发环境 webpack.dev.config.js</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83-webpack-pro-config-js"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">生产环境 webpack.pro.config.js</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6-webpack-config-js"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">入口文件 webpack.config.js</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9-NPM-%E8%84%9A%E6%9C%AC"><span class="toc-number">2.1.2.</span> <span class="toc-text">修改 NPM 脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%84%9A%E6%9C%AC"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">开发环境脚本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E8%84%9A%E6%9C%AC"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">生产环境脚本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-1"><span class="toc-number">2.2.</span> <span class="toc-text">基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.2.1.</span> <span class="toc-text">类型注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">基本数据类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.</span> <span class="toc-text">类与接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.</span> <span class="toc-text">对象类型接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E7%B4%A2%E5%BC%95%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.1.</span> <span class="toc-text">可索引接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.2.</span> <span class="toc-text">函数类型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.3.</span> <span class="toc-text">混合类型接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.</span> <span class="toc-text">函数定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">可选参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">5.3.</span> <span class="toc-text">参数默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">剩余参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">5.5.</span> <span class="toc-text">函数重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">6.1.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">6.2.</span> <span class="toc-text">成员修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#public"><span class="toc-number">6.2.1.</span> <span class="toc-text">public</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#private"><span class="toc-number">6.2.2.</span> <span class="toc-text">private</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#protected"><span class="toc-number">6.2.3.</span> <span class="toc-text">protected</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readonly"><span class="toc-number">6.2.4.</span> <span class="toc-text">readonly</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">6.2.5.</span> <span class="toc-text">构造函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static"><span class="toc-number">6.2.6.</span> <span class="toc-text">static</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">6.3.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">6.4.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.5.</span> <span class="toc-text">this 类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.</span> <span class="toc-text">接口与类的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.1.</span> <span class="toc-text">类类型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">7.2.</span> <span class="toc-text">接口的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E7%B1%BB"><span class="toc-number">7.3.</span> <span class="toc-text">接口继承类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3"><span class="toc-number">7.4.</span> <span class="toc-text">图解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">8.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0%E4%B8%8E%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.2.</span> <span class="toc-text">泛型函数与泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">8.3.</span> <span class="toc-text">泛型类与泛型约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84"><span class="toc-number">8.4.</span> <span class="toc-text">好处</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TypeScript-%E8%BF%9B%E9%98%B6"><span class="toc-number"></span> <span class="toc-text">TypeScript 进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">类型检查机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">1.1.</span> <span class="toc-text">类型推断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">1.1.1.</span> <span class="toc-text">基础类型推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">1.1.2.</span> <span class="toc-text">最佳通用类型推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">1.1.3.</span> <span class="toc-text">上下文类型推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">1.1.4.</span> <span class="toc-text">类型断言</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">类型兼容性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">什么是兼容性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%97%B4%E5%85%BC%E5%AE%B9"><span class="toc-number">1.2.2.</span> <span class="toc-text">接口间兼容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%97%B4%E5%85%BC%E5%AE%B9"><span class="toc-number">1.2.3.</span> <span class="toc-text">函数间兼容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">1.2.4.</span> <span class="toc-text">枚举兼容性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">1.2.5.</span> <span class="toc-text">类兼容性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">1.2.6.</span> <span class="toc-text">泛型兼容性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A3%E8%AF%80"><span class="toc-number">1.2.7.</span> <span class="toc-text">口诀</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.3.</span> <span class="toc-text">类型保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E5%88%9B%E5%BB%BA%E5%8C%BA%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">四种创建区块的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">高级类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">交叉类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">联合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8C%BA%E5%88%86%E7%9A%84%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">可区分的联合类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">索引类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">映射类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.5.</span> <span class="toc-text">条件类型</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        TypeScript 整理手册
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name"></span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-06-29T00:00:00.000Z" itemprop="datePublished">2020-06-29</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/frontEnd/">frontEnd</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/TypeScript/" rel="tag">TypeScript</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>JS 是一门动态弱类型语言，与之对应，自然有静态类型语言和强类型语言。如何区分它们，是在学习一门计算机语言之前首先要搞清楚的问题，理解了这些概念，你就会明白为什么有语言鄙视链，也会对 TS 的诞生的原因有一定的认识。</p>
<span id="more"></span>
<h2 id="类型基础"><a href="#类型基础" class="headerlink" title="类型基础"></a>类型基础</h2><h3 id="强类型语言与弱类型语言"><a href="#强类型语言与弱类型语言" class="headerlink" title="强类型语言与弱类型语言"></a>强类型语言与弱类型语言</h3><h4 id="什么是强类型语言？"><a href="#什么是强类型语言？" class="headerlink" title="什么是强类型语言？"></a>什么是强类型语言？</h4><p>人们对这个概念有不同的理解与定义。</p>
<p>比较早的定义，在强类型语言中，当一个对象从调用函数传递到被调用函数时，其类型必须与被调用函数中声明的类型兼容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">A</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	B(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">b</span>(<span class="params">y</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// y 可以被赋值 想、，运行良好</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是比较早的定义，约束不是那么严格，后面我们一般这么定义：</p>
<blockquote>
<p>强类型语言：不允许改变变量的数据类型，除非进行强制类型转换</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">boolean</span> y = <span class="keyword">true</span>;</span><br><span class="line">    x = y;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">    <span class="comment">// incompatible types: boolean cannot be converted to int</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样代码会报错，因为两者类型不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x = y;</span></span><br><span class="line"><span class="keyword">char</span> z = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">x = z;</span><br><span class="line">System.out.println(x); <span class="comment">// 97</span></span><br></pre></td></tr></table></figure>

<p>这里 java 进行了强制类型转换，这样 x 就保持了整形</p>
<h4 id="什么是弱类型语言？"><a href="#什么是弱类型语言？" class="headerlink" title="什么是弱类型语言？"></a>什么是弱类型语言？</h4><blockquote>
<p>弱类型语言：变量可以被赋予不同的数据类型</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="literal">true</span></span><br><span class="line">x = y</span><br><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到 x 变成了 true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> z = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">x = z</span><br><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">// a</span></span><br></pre></td></tr></table></figure>

<p>这里 x 又变成了字符串</p>
<p>从这里可以看出 JS 是一门弱类型语言</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>强类型语言中，变量类型转换有严格限制，不同类型的变量还不能相互赋值的，这样就能避免很多类型造成的错误。弱类型语言则没什么约束，虽然运用更灵活，但是更容易出现错误。</p>
<hr>
<h3 id="静态类型语言与动态类型语言"><a href="#静态类型语言与动态类型语言" class="headerlink" title="静态类型语言与动态类型语言"></a>静态类型语言与动态类型语言</h3><blockquote>
<p>静态类型语言：在编译阶段确定所有变量的类型</p>
<p>动态类型语言：在执行阶段确定所有变量的类型</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg8y5jkwumj30lr07340e.jpg" alt="image-20200629102410028"></p>
<p>JS 编译器看到这段代码时，无法确定 <code>a</code> 和 <code>b</code> 的类型，只有程序执行时根据传进来的对象才能确定。</p>
<p>C++ 在编译的时候就能确定变量的类型了。</p>
<h4 id="JavaScript-与-C-对比"><a href="#JavaScript-与-C-对比" class="headerlink" title="JavaScript 与 C++ 对比"></a>JavaScript 与 C++ 对比</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg8y836cn8j30lw09tmyo.jpg" alt="image-20200629102639343"></p>
<p>由此看出，动态类型语言，无论是在时间还是空间上都有较多的损耗。</p>
<h4 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg8ya27rofj30e7095ta6.jpg" alt="image-20200629102833392"></p>
<h4 id="其他定义"><a href="#其他定义" class="headerlink" title="其他定义"></a>其他定义</h4><p>强类型语言：不允许程序在发生错误后继续执行</p>
<p>争议：C/C++ 就不是上面所说的强类型语言，没有对数组越界进行检查</p>
<hr>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><h4 id="语言类型象限"><a href="#语言类型象限" class="headerlink" title="语言类型象限"></a>语言类型象限</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg8ydimjv6j30ib09qq3k.jpg" alt="image-20200629103153332"></p>
<p>问题：TypeScript 是什么类型语言？</p>
<blockquote>
<p>TS是强类型，面向对象，编译型的语言。</p>
</blockquote>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>正式开始 TypeScript 程序编写（Helloworld）</p>
<p>准备一个 ts 目录然后用 vscode 编辑他：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg8yqf0aayj305i01hmx3.jpg" alt="image-20200629104418006"></p>
<h3 id="创建-TypeScript-项目"><a href="#创建-TypeScript-项目" class="headerlink" title="创建 TypeScript 项目"></a>创建 TypeScript 项目</h3><ol>
<li>打开控制台，创建 <code>package.json</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y    </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装 TypeScript（全局）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i typescript -g</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>查看 tsc 帮助信息验证安装</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc -h</span><br></pre></td></tr></table></figure>

<p>我们可以看到很多配置项目，这些项目可以通过一个配置文件来实现</p>
<ol start="4">
<li>创建配置项 <code>tsconfig.json</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure>

<p>这个文件有完整的注释</p>
<ol start="5">
<li>新建目录创建文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir src</span><br><span class="line">cd scr</span><br><span class="line">touch index.ts</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>编写文件</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello : <span class="built_in">string</span> = <span class="string">&#x27;hello typescript&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>编译这个文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc ./src/index.ts</span><br></pre></td></tr></table></figure>

<p>我们可以看到一个新的 JavaScript 文件输出了，看一下它的内容</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="string">&#x27;hello typescript&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>除此之外我们还可以通过官网的 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/play">playground</a> 来查看编译结果：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg8z4d2u3wj31f508wgnd.jpg" alt="image-20200629105743889"></p>
<p>输出的结果和 tsc 是一样的</p>
<h4 id="配置构建工具"><a href="#配置构建工具" class="headerlink" title="配置构建工具"></a>配置构建工具</h4><p>使用 webpack 管理我们的工程（三个包）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli webpack-dev-server -D</span><br></pre></td></tr></table></figure>

<p>配置 webpack 的时候，需要区分开发环境和生产环境，因为两个环境是不一样的，需要做不一样的配置。为了配置的可维护性，我们可以将开发环境的配置，生产环境的配置还有公共配置分开书写，最后通过插件进行合并。</p>
<ul>
<li><code>webpack.config.js</code>：所有文件的入口</li>
<li><code>webpack.base.config.js</code>：公共环境的配置</li>
<li><code>webpack.dev.config.js</code>  ：开发环境的配置</li>
<li><code>webpack.pro.config.js</code>  ：生产环境的配置</li>
</ul>
<h5 id="公共环境配置-webpack-base-config-js"><a href="#公共环境配置-webpack-base-config-js" class="headerlink" title="公共环境配置 webpack.base.config.js"></a>公共环境配置 <code>webpack.base.config.js</code></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/index.ts&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;app.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        extensions: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.tsx&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.tsx?$/i</span>,</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: <span class="string">&#x27;ts-loader&#x27;</span></span><br><span class="line">                &#125;],</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">&#x27;./src/tpl/index.html&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先指定了一个入口文件 <code>./src/index.ts</code></p>
</li>
<li><p>然后输出文件名是 <code>app.js</code>，使用默认的根目录</p>
</li>
<li><p>使用三个扩展名 <code>.js</code> <code>.ts</code> <code>.tsx</code></p>
</li>
<li><p>既然我们引入了新的文件 ts，那就需要使用相应的 <code>loader</code>，我们安装 <code>ts-loader</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i ts-loader typescript -D // 还需要本地安装一下 typescript</span><br></pre></td></tr></table></figure></li>
<li><p>ts-loader 的正则：<code>/\.tsx?$/i</code>，并排除 node_module 下的文件</p>
</li>
<li><p>插件 <code>HtmlWebpackPlugin</code>：通过一个模板帮助生成网站首页，而且帮助把输出文件自动嵌入到模板文件中，安装一下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i html-webpack-plugin -D</span><br></pre></td></tr></table></figure></li>
<li><p>编写一下模板文件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// ./src/tpl/index.html</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>TypeScript<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="开发环境-webpack-dev-config-js"><a href="#开发环境-webpack-dev-config-js" class="headerlink" title="开发环境 webpack.dev.config.js"></a>开发环境 <code>webpack.dev.config.js</code></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    devtool: <span class="string">&#x27;cheap-module-eval-source-map&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是官方推荐的配置，</p>
<ol>
<li><code>cheap</code> 表示忽略文件的列信息（调试这个没用）</li>
<li><code>module</code> 表示定位到 <code>TypeScript</code> 源码，而不是经 <code>loader</code> 转义的 <code>JavaScript</code> 源码</li>
<li><code>eval-source-map</code> 表示会将 <code>source-map</code> 以 <code>dataUrl</code> 的形式打包到文件中，重编译速度是很快的，不用担心性能问题。</li>
</ol>
<h5 id="生产环境-webpack-pro-config-js"><a href="#生产环境-webpack-pro-config-js" class="headerlink" title="生产环境 webpack.pro.config.js"></a>生产环境 <code>webpack.pro.config.js</code></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个作用是，在每次成功构建之后，帮助我们清空 <code>dist</code> 目录。因为有的时候为了避免缓存，会在文件后加入哈希，在多次构建后会产生很多无用文件。这个插件会帮我们清空目录。我们安装一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i clean-webpack-plugin -D</span><br></pre></td></tr></table></figure>



<h5 id="入口文件-webpack-config-js"><a href="#入口文件-webpack-config-js" class="headerlink" title="入口文件 webpack.config.js"></a>入口文件 <code>webpack.config.js</code></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.base.config&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> devConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.dev.config&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> proConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.pro.config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">env, argv</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> config = argv.mode === <span class="string">&#x27;development&#x27;</span> ? devConfig : proConfig;</span><br><span class="line">    <span class="keyword">return</span> merge(baseConfig, config);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用了一个合并插件，我们安装一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack-merge -D</span><br></pre></td></tr></table></figure>

<h4 id="修改-NPM-脚本"><a href="#修改-NPM-脚本" class="headerlink" title="修改 NPM 脚本"></a>修改 NPM 脚本</h4><h5 id="开发环境脚本"><a href="#开发环境脚本" class="headerlink" title="开发环境脚本"></a>开发环境脚本</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./src/index.ts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;webpack-dev-server --mode=development --config ./build/webpack.config&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>运行一下 <code>npm start</code>，我们可以看到效果：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg913pdv9lj30b200ndfs.jpg" alt="image-20200629120625940"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg913ugnt8j30ne01tmxi.jpg" alt="image-20200629120634351"></p>
<p>可以在模板 html 中写一些东西：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span>123123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后就能在 <code>http://127.0.0.1:8080</code> 中看到</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg915mnf51j309503pq2w.jpg" alt="image-20200629120815821"></p>
<h5 id="生产环境脚本"><a href="#生产环境脚本" class="headerlink" title="生产环境脚本"></a>生产环境脚本</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack --mode=produnction --config ./build/webpack.config.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;webpack-dev-server --mode=development --config ./build/webpack.config&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>运行一下 <code>npm run build</code>：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg91cgjgcbj30hw06n3zn.jpg" alt="image-20200629121451340"></p>
<p>我们能看在目录中看到 <code>dist</code>，构建好的 <code>app.js</code> 也嵌入到模板文件中。</p>
<hr>
<h3 id="基本类型-1"><a href="#基本类型-1" class="headerlink" title="基本类型"></a>基本类型</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg8ymh7rkxj30gg09zgmi.jpg" alt="image-20200629104030469"></p>
<p>ES6 有 6 种基本数据类型，还有 3 种引用类型，TypeScript 又新增了几个类型。</p>
<h4 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h4><blockquote>
<p>作用：相当于强类型语言的类型声明</p>
<p>语法：(变量/函数):type</p>
</blockquote>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>到创建好的工程目录去，在 <code>src</code> 下创建 <code>datatype.ts</code> 文件，并引入到 <code>index.ts</code></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/datatype.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始类型</span></span><br><span class="line"><span class="keyword">let</span> bool: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">123</span></span><br><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> arr1: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr3: <span class="built_in">Array</span>&lt;<span class="built_in">number</span> | <span class="built_in">string</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元祖</span></span><br><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">number</span>, <span class="built_in">string</span>] = [<span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>]</span><br><span class="line"><span class="comment">// 元祖越界问题</span></span><br><span class="line">tuple.push(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(tuple) <span class="comment">// 打印三个元素</span></span><br><span class="line"><span class="comment">// tuple[2] // 不允许越界访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="comment">// let add = (x, y) =&gt; x + y // 需要类型注解</span></span><br><span class="line"><span class="keyword">let</span> add = (x: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> x + y</span><br><span class="line"><span class="comment">// 返回值可以省略：TS 的推断</span></span><br><span class="line"><span class="comment">// 没有具体实现的函数类型</span></span><br><span class="line"><span class="keyword">let</span> compute: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"><span class="comment">// 具体实现它</span></span><br><span class="line">compute = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="comment">// let obj: object = &#123;x: 1, y: 3&#125; // 简单指定类型，没有定义属性</span></span><br><span class="line"><span class="keyword">let</span> obj: &#123;<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">3</span>&#125;</span><br><span class="line">obj.x = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol</span></span><br><span class="line"><span class="keyword">let</span> s1: symbol = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined, null</span></span><br><span class="line"><span class="comment">// 不能赋值其他数据类型</span></span><br><span class="line"><span class="keyword">let</span> un: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> nu: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 别的数据类型可以被赋值，需要设置 tsconfig</span></span><br><span class="line"><span class="comment">// &quot;strictNullChecks&quot;: false</span></span><br><span class="line"><span class="comment">// let num: number | undefined | null = 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void</span></span><br><span class="line"><span class="keyword">let</span> noReturn = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="comment">// js 中 void 是一种操作符，可以让任何表达式返回 undefined</span></span><br><span class="line"><span class="comment">// void 0 // 因为 undefined 不是一个保留字，可以被修改覆盖</span></span><br><span class="line"><span class="comment">// ts 中 void 是一个没有任何返回值的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// any</span></span><br><span class="line"><span class="keyword">let</span> x</span><br><span class="line"><span class="comment">// ts 中不指定一个变量类型，默认就是 any</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// never</span></span><br><span class="line"><span class="keyword">let</span> error = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> endless = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 永远不会有返回值的类型：函数抛出异常，死循环函数</span></span><br></pre></td></tr></table></figure>

<p>TypeScript 完全覆盖了 ES6 的基本数据类型，并通过 <code>any</code> 实现了对 JS 的兼容</p>
<hr>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>一个角色判断的例子：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg92gtghkrj30ke068405.jpg" alt="image-20200629125343475"></p>
<blockquote>
<p>枚举：一组有名字的常量集合</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg92hwlsmej30dj03uaam.jpg" alt="image-20200629125446183"></p>
<p>接着之前的工程，新建 <code>enum.ts</code> 文件：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字枚举</span></span><br><span class="line"><span class="built_in">enum</span> Role &#123;</span><br><span class="line">  Reporter,</span><br><span class="line">  Developer,</span><br><span class="line">  Maintainer,</span><br><span class="line">  Owner,</span><br><span class="line">  Guest</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Role.Reporter)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(Role.Developer) <span class="comment">// 1 递增</span></span><br><span class="line"><span class="built_in">console</span>.log(Role) <span class="comment">// 编译成一个对象</span></span><br><span class="line"><span class="comment">// 自定义初始值</span></span><br><span class="line"><span class="comment">// enum Role &#123;</span></span><br><span class="line"><span class="comment">//   Reporter,</span></span><br><span class="line"><span class="comment">//   Developer,</span></span><br><span class="line"><span class="comment">//   Maintainer,</span></span><br><span class="line"><span class="comment">//   Owner,</span></span><br><span class="line"><span class="comment">//   Guest</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &quot;use strict&quot;;</span></span><br><span class="line"><span class="comment">// var Role;</span></span><br><span class="line"><span class="comment">// (function (Role) &#123;</span></span><br><span class="line"><span class="comment">//     Role[Role[&quot;Reporter&quot;] = 0] = &quot;Reporter&quot;;</span></span><br><span class="line"><span class="comment">//     Role[Role[&quot;Developer&quot;] = 1] = &quot;Developer&quot;;</span></span><br><span class="line"><span class="comment">//     Role[Role[&quot;Maintainer&quot;] = 2] = &quot;Maintainer&quot;;</span></span><br><span class="line"><span class="comment">//     Role[Role[&quot;Owner&quot;] = 3] = &quot;Owner&quot;;</span></span><br><span class="line"><span class="comment">//     Role[Role[&quot;Guest&quot;] = 4] = &quot;Guest&quot;;</span></span><br><span class="line"><span class="comment">// &#125;)(Role || (Role = &#123;&#125;));</span></span><br><span class="line"><span class="comment">// 反向映射，枚举的实现原理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串枚举</span></span><br><span class="line"><span class="built_in">enum</span> Message &#123;</span><br><span class="line">  Success = <span class="string">&#x27;成功&#x27;</span>,</span><br><span class="line">  Fail = <span class="string">&#x27;失败&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不可以反向映射</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异构枚举</span></span><br><span class="line"><span class="built_in">enum</span> Answer &#123;</span><br><span class="line">  N,</span><br><span class="line">  Y = <span class="string">&#x27;yes&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 容易引起混淆，不建议使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举成员性质</span></span><br><span class="line"><span class="comment">// Role.Reporter = 2 // 只读类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举成员</span></span><br><span class="line"><span class="built_in">enum</span> Char &#123;</span><br><span class="line">  <span class="comment">// const 常量枚举（没有初始值，对成员引用，常量表达式）</span></span><br><span class="line">  <span class="comment">// 编译阶段出结果</span></span><br><span class="line">  a,</span><br><span class="line">  b = Char.a,</span><br><span class="line">  c = <span class="number">1</span> + <span class="number">3</span>,</span><br><span class="line">  <span class="comment">// computed 需要被计算</span></span><br><span class="line">  <span class="comment">// 执行阶段出结果</span></span><br><span class="line">  d = <span class="built_in">Math</span>.random(),</span><br><span class="line">  e = <span class="string">&#x27;123&#x27;</span>.length,</span><br><span class="line">  <span class="comment">// computed 后面的成员需要初始值</span></span><br><span class="line">  f = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// var Char;</span></span><br><span class="line"><span class="comment">// (function (Char) &#123;</span></span><br><span class="line"><span class="comment">//     Char[Char[&quot;a&quot;] = 0] = &quot;a&quot;;</span></span><br><span class="line"><span class="comment">//     Char[Char[&quot;b&quot;] = 0] = &quot;b&quot;;</span></span><br><span class="line"><span class="comment">//     Char[Char[&quot;c&quot;] = 4] = &quot;c&quot;;</span></span><br><span class="line"><span class="comment">//     Char[Char[&quot;d&quot;] = Math.random()] = &quot;d&quot;;</span></span><br><span class="line"><span class="comment">//     Char[Char[&quot;e&quot;] = &#x27;123&#x27;.length] = &quot;e&quot;;</span></span><br><span class="line"><span class="comment">// &#125;)(Char || (Char = &#123;&#125;));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量枚举</span></span><br><span class="line"><span class="comment">// 编译阶段移除</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">enum</span> Month &#123;</span><br><span class="line">  Jan,</span><br><span class="line">  Feb,</span><br><span class="line">  Mar</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当我们不需要一个对象，而需要对象的值</span></span><br><span class="line"><span class="keyword">let</span> month = [Month.Jan, Month.Feb] <span class="comment">// 值直接替换成常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举类型</span></span><br><span class="line"><span class="comment">// 三种情况下，枚举和枚举成员都可以作为单独类型存在</span></span><br><span class="line"><span class="built_in">enum</span> E &#123; a, b &#125;</span><br><span class="line"><span class="built_in">enum</span> F &#123; a = <span class="number">0</span>, b = <span class="number">1</span> &#125;</span><br><span class="line"><span class="built_in">enum</span> G &#123; a= <span class="string">&#x27;apple&#x27;</span>, b = <span class="string">&#x27;banana&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> e: E = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> f: F = <span class="number">3</span></span><br><span class="line"><span class="comment">// e === f // 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> e1: E.a</span><br><span class="line"><span class="keyword">let</span> e2: E.b</span><br><span class="line"><span class="keyword">let</span> e3: E.a = <span class="number">1</span></span><br><span class="line"><span class="comment">// e1 === e2 // 报错</span></span><br><span class="line"><span class="comment">// e1 === e3 // 可以比较</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串枚举取值只能是枚举成员的类型</span></span><br><span class="line"><span class="keyword">let</span> g1: G = G.b</span><br><span class="line"><span class="keyword">let</span> g2: G.a = G.a <span class="comment">// 只能这样赋值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>枚举：帮助我们将程序中不容易记忆的硬编码或者是未来中可能改变的常量抽取出来，提高程序可读性、可维护性</p>
<hr>
<h2 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h2><h3 id="对象类型接口"><a href="#对象类型接口" class="headerlink" title="对象类型接口"></a>对象类型接口</h3><p>接口可以约束对象，函数以及类的结构和类型，这是一种代码协作的契约，我们必须遵守并且不能改变。我们来看一个对象类型的接口是怎么定义的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> List &#123;</span><br><span class="line">  id: <span class="built_in">number</span>,</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Result &#123;</span><br><span class="line">  data: List[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">result: Result</span>) </span>&#123;</span><br><span class="line">  result.data.forEach(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val.id, val.name)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = &#123;</span><br><span class="line">  data: [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;A&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;B&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render(result)</span><br></pre></td></tr></table></figure>

<p>实际开发中，我们经常会接收到后端传递过来的意料之外的字段，会发生什么呢？</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = &#123;</span><br><span class="line">  data: [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;A&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;male&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;B&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候没有报错，因为鸭式变形法：看上去是，那他就是。换到 TS 上就是，只要传入的对象满足接口的必要条件，那么它就被允许，即使传入多余字段。</p>
<p>有一个例外，如果我们直接传入对象自变量，它就会对额外字段进行类型检查：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render( &#123;</span><br><span class="line">  data: [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;A&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;male&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;B&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>三种解决方法：</p>
<ol>
<li><p>对象自变量赋值给变量</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render(result)</span><br></pre></td></tr></table></figure></li>
<li><p>类型断言</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">render( &#123;</span><br><span class="line">  data: [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;A&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;male&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;B&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125; <span class="keyword">as</span> Result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// React 中不建议使用</span></span><br><span class="line">render(&lt;Result&gt; &#123;</span><br><span class="line">  data: [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;A&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;male&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;B&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125; <span class="keyword">as</span> Result)</span><br></pre></td></tr></table></figure></li>
<li><p> 字符串索引签名</p>
</li>
</ol>
   <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> List &#123;</span><br><span class="line">  id: <span class="built_in">number</span>,</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  [x: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   用任意字符串索引 List</p>
<p>接口成员的一些属性：</p>
<p>可选</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> List &#123;</span><br><span class="line">  id: <span class="built_in">number</span>,</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  [x: <span class="built_in">string</span>]: <span class="built_in">any</span>,</span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">result: Result</span>) </span>&#123;</span><br><span class="line">  result.data.forEach(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val.id, val.name)</span><br><span class="line">    <span class="keyword">if</span>(val.age) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(val.age)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只读</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> List &#123;</span><br><span class="line">  <span class="keyword">readonly</span> id: <span class="built_in">number</span>,</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  [x: <span class="built_in">string</span>]: <span class="built_in">any</span>,</span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可索引接口"><a href="#可索引接口" class="headerlink" title="可索引接口"></a>可索引接口</h4><p>当你不确定一个接口中有多少个属性时，就可以使用可索引类型的接口，可索引类型的接口可以用数字索引，也可以是字符串。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> chars: StringArray = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>用任意数字索引 <code>StringArray</code> 都会得到一个 <code>string</code>，相当于声明了一个字符串数组</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Names &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">string</span>,</span><br><span class="line">  <span class="comment">// x: number 不可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用任意 string 索引，得到的都是 string，而且不能再声明 number 类型成员</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Names &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">string</span>,</span><br><span class="line">  <span class="comment">// x: number 不可以</span></span><br><span class="line">  [z: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>索引可以混用，需要注意的是，数字索引签名返回值一定要是字符串索引签名返回值的子类型，因为 JavaScript 会类型转换，将 number 转换为 string</p>
<h3 id="函数类型接口"><a href="#函数类型接口" class="headerlink" title="函数类型接口"></a>函数类型接口</h3><p>使用接口定义一个函数，之前用变量声明了一个函数类型，现在我们用接口实现一遍：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Add &#123;</span><br><span class="line">  (x: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种方式等价，还有一种更简洁的方式：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Add = &#123;<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>&#125; =&gt; <span class="built_in">number</span></span><br></pre></td></tr></table></figure>

<p>这是使用类型别名来声明函数类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Add = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add: Add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br></pre></td></tr></table></figure>

<h3 id="混合类型接口"><a href="#混合类型接口" class="headerlink" title="混合类型接口"></a>混合类型接口</h3><p>一个接口既可以定义一个函数，又可以像对象一样，拥有属性和方法</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lib &#123;</span><br><span class="line">  (): <span class="built_in">void</span>,</span><br><span class="line">  version: <span class="built_in">string</span>,</span><br><span class="line">  doSomething(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义完成后我们来实现它：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lib: Lib = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">lib.version = <span class="string">&#x27;1.0&#x27;</span></span><br><span class="line">lib.doSomething = <span class="function">() =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>还是报错，这时候就需要使用断言：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lib: Lib = (<span class="function">() =&gt;</span> &#123;&#125;) <span class="keyword">as</span> Lib</span><br><span class="line">lib.version = <span class="string">&#x27;1.0&#x27;</span></span><br><span class="line">lib.doSomething = <span class="function">() =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>实现了一个混合接口，但是向全局暴露了一个变量 <code>lib</code>，它是一个单例，如果我们创建了多个 lib，就需要封装一下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLib</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lib: Lib = (<span class="function">() =&gt;</span> &#123;&#125;) <span class="keyword">as</span> Lib</span><br><span class="line">  lib.version = <span class="string">&#x27;1.0&#x27;</span></span><br><span class="line">  lib.doSomething = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> lib</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lib1 = getLib()</span><br><span class="line">lib1()</span><br><span class="line">lib1.doSomething</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lib2 = getLib()</span><br></pre></td></tr></table></figure>

<p>接口还可以定义类的结构与类型，之后再讲</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add2: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> add3 = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> add4 &#123;</span><br><span class="line">  (x: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要明确指出函数参数的类型与个数，而返回值可以使用 ts 的类型推断。后三种只是函数类型的定义（函数声明），缺少函数体。</p>
<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add5</span>(<span class="params">x: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> y? x + y : x</span><br><span class="line">&#125;</span><br><span class="line">add5(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>要注意的是，可选参数不能在必选参数之前。</p>
<h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><p>类似 ES6 的形式</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add6</span>(<span class="params">x: <span class="built_in">number</span>, y = <span class="number">2</span>, z: <span class="built_in">number</span>, q = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z + q</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在必选参数之前，默认参数是不可以省略的，必须明确传入 <code>undefined</code></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add6(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>剩余参数是以数组形式存储的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add7</span>(<span class="params">x: <span class="built_in">number</span>, ...rest: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + rest.reduce(<span class="function">(<span class="params">p, c</span>) =&gt;</span>  p + c )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>静态类型语言中都有这个概念，两个函数如果名称相同，但是参数个数与参数类型不同，那么就实现了函数重载，增强了函数的可读性与可扩展性</p>
<p>TS 的函数重载要求我们先定义一系列名称相同的函数声明：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add8</span>(<span class="params">...rest: <span class="built_in">number</span>[]</span>): <span class="title">number</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">add8</span>(<span class="params">...rest: <span class="built_in">string</span>[]</span>): <span class="title">string</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">add8</span>(<span class="params">...rest: <span class="built_in">any</span>[]</span>): <span class="title">any</span> </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">  <span class="title">let</span> <span class="title">first</span> = <span class="title">rest</span>[0]</span></span></span><br><span class="line"><span class="function"><span class="function">  <span class="title">if</span>(<span class="params"><span class="keyword">typeof</span> first === <span class="string">&#x27;string&#x27;</span></span>) </span>&#123;</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">rest</span>.<span class="title">join</span>(<span class="params"><span class="string">&#x27;&#x27;</span></span>)</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">  <span class="title">if</span>(<span class="params"><span class="keyword">typeof</span> first === <span class="string">&#x27;number&#x27;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rest.reduce(<span class="function">(<span class="params">p, c</span>) =&gt;</span> p + c)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">add8(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">add8(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>TS 在重载时会查找重载列表，，所以我们要将容易匹配的函数定义写在前面</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>ES6 引入了 class 关键字，我们终于可以像后端语言一样实现面向对象了，TS 的类覆盖了 ES6 的类，并且引入了一些其他特性</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Dog.prototype)</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog(<span class="string">&#x27;wangcai&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(dog)</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;wangcai&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Dog.prototype)</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line"><span class="built_in">console</span>.log(dog)</span><br></pre></td></tr></table></figure>

<p>与 ES6 不同的是，我们添加了类型注解，此外还有一个 run() 方法，返回值是 void，还有一个构造函数的返回值，返回 Dog 本身（自动推断），注意两个问题：</p>
<ol>
<li>无论在 ES 还是 TS 中，类成员的属性都是实例属性而不是原型属性，类成员方法都是实例方法</li>
<li>与 ES 不同的是，实例属性必须要有初始值或者在构造函数中被初始化</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Husky</span> <span class="keyword">extends</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, color: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name)</span><br><span class="line">    <span class="built_in">this</span>.color = color</span><br><span class="line">  &#125;</span><br><span class="line">  color: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES 规定派生类的构造函数必须包含 <code>super()</code> 调用，代表父类实例，<code>this</code> 需要放在构造函数之后</p>
<h3 id="成员修饰符"><a href="#成员修饰符" class="headerlink" title="成员修饰符"></a>成员修饰符</h3><p>这是 TS 对 ES 的一种扩展</p>
<h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><p>默认修饰符，对所有人可见</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> name: <span class="built_in">string</span> = <span class="string">&#x27;dog&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>只能在类的本身被调用，实例都不行</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="title">pri</span>(<span class="params"></span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>可以给构造函数加上私有成员属性，作用是这个类既不能被实例化，也不能被继承</p>
<h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><p>受保护成员只能在类或者子类中访问，而不能在实例中访问</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="title">pro</span>(<span class="params"></span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>可以给构造函数加上受保护属性，作用是这个类只能被继承，也就是实现了一个基类</p>
<h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h4><p>只读属性不可以被更改，只读属性一定要被初始化，和实例属性一样的</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">readonly</span> legs： <span class="built_in">number</span> = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="构造函数参数"><a href="#构造函数参数" class="headerlink" title="构造函数参数"></a>构造函数参数</h4><p>将参数变为了实例属性，这样我们就不用在类中定义了，更简洁</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Husky</span> <span class="keyword">extends</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, <span class="keyword">public</span> color: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name)</span><br><span class="line">    <span class="built_in">this</span>.color = color</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// color: string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>类的静态成员</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> food: <span class="built_in">string</span> = <span class="string">&#x27;bones&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>静态成员只能通过类名来调用，不能通过实例或者子类调用</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>ES 中并没有引入抽象类的概念，所谓抽象类就是只能被继承，不能被实例化的类</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let animal = new Animal</span></span><br></pre></td></tr></table></figure>

<p>抽象类中可以定义具体的方法，子类就不用实现了，达成了方法的复用</p>
<p>抽象类中可以不完成一个方法的具体实现，抽象方法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> sleep(): <span class="built_in">void</span></span><br></pre></td></tr></table></figure>

<p>抽象类可以抽离出类的共性，从而提高代码的复用率</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>父类中定义一个抽象方法，多个子类中对这个方法有不同的实现，实现运行时的绑定</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">sleep</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;dog sleep&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">sleep</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;cat sleep&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat()</span><br><span class="line"><span class="keyword">let</span> animals: Animal[] = [dog, cat]</span><br><span class="line">animals.forEach(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">  i.sleep()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="this-类型"><a href="#this-类型" class="headerlink" title="this 类型"></a>this 类型</h3><p>特殊的 TS 类型，类的成员方法可以直接返回一个 <code>this</code> ，这样就可以很方便地实现链式调用</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkFlow</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">step1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">step2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> WorkFlow().step1().step2()</span><br></pre></td></tr></table></figure>

<p>这样就实现了 TS 类方法的链式调用</p>
<p>this 的多态</p>
<p>this 既可以是父类型，也可以是子类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkFlow</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">step1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">step2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> WorkFlow().step1().step2()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFlow</span> <span class="keyword">extends</span> <span class="title">WorkFlow</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> MyFlow().next().step1().next().step2()</span><br></pre></td></tr></table></figure>

<p>这样就保持了父类与子类间接口调用的连贯性</p>
<hr>
<h2 id="接口与类的关系"><a href="#接口与类的关系" class="headerlink" title="接口与类的关系"></a>接口与类的关系</h2><h3 id="类类型接口"><a href="#类类型接口" class="headerlink" title="类类型接口"></a>类类型接口</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Human &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  eat(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asian</span> <span class="title">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个接口可以约束类有多少属性以及它们的类型，注意点：</p>
<ul>
<li>类实现接口的时候，必须实现接口中所有属性（类可以添加属性）</li>
<li>接口只能约束类的公有成员</li>
<li>接口不能约束类的构造函数</li>
</ul>
<h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>接口可以像类一样实现继承</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Human &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  eat(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Man <span class="keyword">extends</span> Human &#123;</span><br><span class="line">  run(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Child &#123;</span><br><span class="line">  cry(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Boy <span class="keyword">extends</span> Man, Child &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> boy: Boy = &#123;</span><br><span class="line">  name: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">cry</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><p>相当于把类的成员都抽象了出来，也就是只有结构，没有实现</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Auto</span> </span>&#123;</span><br><span class="line">  state = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> AutoInterface <span class="keyword">extends</span> Auto &#123;</span><br><span class="line">  <span class="comment">// 隐含了 state 属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="title">implements</span> <span class="title">AutoInterface</span> </span>&#123;</span><br><span class="line">  state = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Auto</span> <span class="title">implements</span> <span class="title">AutoInterface</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 子类已经有 state 了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口不仅抽象了公共属性，而且把私有成员和受保护成员都抽象出来了</p>
<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg97qcnzchj30h706jq3i.jpg" alt="image-20200629155610543"></p>
<hr>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>希望一个函数或者一个类支持多种数据类型，怎么解决呢？</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg97v44mqij30dn05k3z5.jpg" alt="image-20200629160048424"></p>
<p>我们希望接收字符串数组，那么可以使用函数重载来实现：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg97vzcrufj30dv06twfp.jpg" alt="image-20200629160138362"></p>
<p>还可以用联合类型，更简便一些：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg97wkfb5cj30ih05et9k.jpg" alt="image-20200629160212744"></p>
<p>我们还不满足，希望接收任何类型参数，any 类型：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg97x9nkvrj309d057aaj.jpg" alt="image-20200629160252817"></p>
<p>但是这样会丢失一些约束信息，也就是类型之间的约束关系，忽略了输入参数与返回值的类型必须一致。这个时候就用到泛型了。</p>
<blockquote>
<p>泛型概念：不预先确定的数据类型，具体的类型在使用的时候才能确定</p>
</blockquote>
<h3 id="泛型函数与泛型接口"><a href="#泛型函数与泛型接口" class="headerlink" title="泛型函数与泛型接口"></a>泛型函数与泛型接口</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line">log&lt;<span class="built_in">string</span>[]&gt;([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="comment">// 类型推断，推荐</span></span><br><span class="line">log([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型别名</span></span><br><span class="line"><span class="keyword">type</span> Log = &lt;T&gt;<span class="function">(<span class="params">value: T</span>) =&gt;</span> T</span><br><span class="line"><span class="keyword">let</span> myLog: Log = log</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型接口</span></span><br><span class="line"><span class="keyword">interface</span> Log2 &#123;</span><br><span class="line">  &lt;T&gt;(value: T): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型约束接口所有成员，实现指定类型</span></span><br><span class="line"><span class="keyword">interface</span> Log3&lt;T&gt; &#123;</span><br><span class="line">  (value: T): T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myLog3: Log3&lt;<span class="built_in">number</span>&gt; = log</span><br><span class="line">myLog3(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Log4&lt;T = string&gt; &#123;</span><br><span class="line">  (value: T): T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将泛型变量与函数参数等同对待，只不过是代表值得参数，泛型在高阶函数中有广泛应用。</p>
<h3 id="泛型类与泛型约束"><a href="#泛型类与泛型约束" class="headerlink" title="泛型类与泛型约束"></a>泛型类与泛型约束</h3><p>泛型类</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型不能应用于类的静态成员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params">value: T</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> log1 = <span class="keyword">new</span> Log&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line">log1.run(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> log2 = <span class="keyword">new</span> Log()</span><br><span class="line">log2.run(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;) <span class="comment">// 任意值</span></span><br></pre></td></tr></table></figure>

<p>泛型约束</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value, value.length)</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错，不存在 length</span></span><br></pre></td></tr></table></figure>

<p>预定义接口，进行约束：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Length &#123;</span><br><span class="line">  length: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Length</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value, value.length)</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不管传入什么，必须要有 length 属性（数组、字符串、集合）</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li>增强程序的可扩展性：函数或类可以轻松支持多种数据类型</li>
<li>增强代码的可读性：不必写多条函数重载，或者冗长的联合类型声明</li>
<li>灵活控制类型之间的约束</li>
</ul>
<hr>
<p>到此，基础知识基本介绍结束</p>
<h1 id="TypeScript-进阶"><a href="#TypeScript-进阶" class="headerlink" title="TypeScript 进阶"></a>TypeScript 进阶</h1><h2 id="类型检查机制"><a href="#类型检查机制" class="headerlink" title="类型检查机制"></a>类型检查机制</h2><blockquote>
<p>类型检查机制：TypeScript 编译器在做类型检查时，秉承的一些原则，以及表现出的一些行为</p>
</blockquote>
<p>作用：辅助开发，提高效率</p>
<ul>
<li>类型推断</li>
<li>类型兼容性</li>
<li>类型保护</li>
</ul>
<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><blockquote>
<p>不用指定变量的类型（函数的返回值类型），TypeScript 可以根据某些规则自动为其推断一个类型</p>
</blockquote>
<ul>
<li>基础类型推断</li>
<li>最佳通用类型推断</li>
<li>上下文类型推断</li>
</ul>
<h4 id="基础类型推断"><a href="#基础类型推断" class="headerlink" title="基础类型推断"></a>基础类型推断</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="function">(<span class="params">x = <span class="number">1</span></span>) =&gt;</span> x + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="最佳通用类型推断"><a href="#最佳通用类型推断" class="headerlink" title="最佳通用类型推断"></a>最佳通用类型推断</h4><p>需要从多个类型中推断类型时，TS 会尽可能推断一个兼容所有类型的，通用的类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// number || null</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="literal">null</span>] </span><br></pre></td></tr></table></figure>

<h4 id="上下文类型推断"><a href="#上下文类型推断" class="headerlink" title="上下文类型推断"></a>上下文类型推断</h4><p>上面两个都是从右到左的推断，上下文是从左到右的推断，通常发生在事件处理中</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onkeydown = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// KeyboardEvent</span></span><br><span class="line">  <span class="built_in">console</span>.log(event) <span class="comment">// 键盘事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>以上三个方法可能不符合你的预期，TS 也提供了一个方法供你覆盖推断类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;&#125;</span><br><span class="line">foo.bar = <span class="number">1</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">	bar: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = &#123;&#125; <span class="keyword">as</span> Foo</span><br><span class="line">foo.bar = <span class="number">1</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>类型断言不能乱用：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">	bar: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = &#123;&#125; <span class="keyword">as</span> Foo</span><br></pre></td></tr></table></figure>

<p>这时候没有按照接口约定严格拥有属性，怎么办呢？：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">	bar: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo: Foo = &#123;</span><br><span class="line">	bar: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这才是最佳方法</p>
<hr>
<h3 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h3><h4 id="什么是兼容性"><a href="#什么是兼容性" class="headerlink" title="什么是兼容性"></a>什么是兼容性</h4><blockquote>
<p>当一个类型 Y 可以赋值给另一个类型 X 时，我们就可以说类型 X 兼容类型 Y</p>
</blockquote>
<p>X 兼容 Y：X（目标类型） = Y（源类型）</p>
<h4 id="接口间兼容"><a href="#接口间兼容" class="headerlink" title="接口间兼容"></a>接口间兼容</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口兼容性</span></span><br><span class="line"><span class="keyword">interface</span> X &#123;</span><br><span class="line">  a: <span class="built_in">any</span>,</span><br><span class="line">  b: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Y &#123;</span><br><span class="line">  a: <span class="built_in">any</span>,</span><br><span class="line">  b: <span class="built_in">any</span>,</span><br><span class="line">  c: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: X = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">let</span> y: Y = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;</span><br><span class="line">x = y <span class="comment">// true</span></span><br><span class="line">y = x <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>源类型只要有目标类型的必要属性，就可以进行赋值</p>
<h4 id="函数间兼容"><a href="#函数间兼容" class="headerlink" title="函数间兼容"></a>函数间兼容</h4><p>常用于函数作为参数回调的场景</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数兼容性</span></span><br><span class="line"><span class="keyword">type</span> Handler = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hof</span>(<span class="params">handler: Handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1) 参数个数</span></span><br><span class="line"><span class="keyword">let</span> handler1 = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> &#123;&#125;</span><br><span class="line">hof(handler1) <span class="comment">// 可以</span></span><br><span class="line"><span class="keyword">let</span> handler2 = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, c: <span class="built_in">number</span></span>) =&gt;</span> &#123;&#125;</span><br><span class="line">hof(handler2) <span class="comment">// 不可以</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选参数 / 剩余参数</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="function">(<span class="params">p1: <span class="built_in">number</span>, p2: <span class="built_in">number</span></span>) =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="function">(<span class="params">p1?: <span class="built_in">number</span>, p2?: <span class="built_in">number</span></span>) =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="function">(<span class="params">...args: <span class="built_in">number</span>[]</span>) =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 固定参数是可以兼容可选参数与剩余参数的</span></span><br><span class="line"><span class="comment">// 可选参数是不兼容固定参数与剩余参数的</span></span><br><span class="line"><span class="comment">// 剩余参数可以兼容两者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2) 参数类型</span></span><br><span class="line"><span class="comment">// 类型一定要匹配</span></span><br><span class="line"><span class="keyword">let</span> handler3 = <span class="function">(<span class="params">a: <span class="built_in">string</span></span>) =&gt;</span> &#123;&#125;</span><br><span class="line">hof(handler3) <span class="comment">// 不可以</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point3D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>,</span><br><span class="line">  y: <span class="built_in">number</span>,</span><br><span class="line">  z: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point2D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>,</span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3d = <span class="function">(<span class="params">point: Point3D</span>) =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> p2d = <span class="function">(<span class="params">point: Point2D</span>) =&gt;</span> &#123;&#125;</span><br><span class="line">p3d = p2d <span class="comment">// 兼容</span></span><br><span class="line">p2d = p3d <span class="comment">// 不兼容</span></span><br><span class="line"><span class="comment">// 函数参数的双向协变，特殊例子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3) 返回值类型</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="function">() =&gt;</span>  (&#123;<span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> g = <span class="function">() =&gt;</span>  (&#123;<span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">location</span>: <span class="string">&#x27;shanghai&#x27;</span>&#125;)</span><br><span class="line">f = g <span class="comment">// 兼容</span></span><br><span class="line">g = f <span class="comment">// 不兼容</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">overload</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">overload</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="title">string</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">overload</span>(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="function">// <span class="function"><span class="keyword">function</span> <span class="title">overload</span>(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span></span>) </span>&#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="function">// <span class="function"><span class="keyword">function</span> <span class="title">overload</span>(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span>, c: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;&#125;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="枚举兼容性"><a href="#枚举兼容性" class="headerlink" title="枚举兼容性"></a>枚举兼容性</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举兼容性</span></span><br><span class="line"><span class="comment">// 枚举和 number 兼容</span></span><br><span class="line"><span class="built_in">enum</span> Fruit &#123; Apple, Banana &#125;</span><br><span class="line"><span class="built_in">enum</span> Color &#123; Red, Blue &#125;</span><br><span class="line"><span class="keyword">let</span> fruit: Fruit.Apple = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> no: <span class="built_in">number</span> = Fruit.Apple <span class="comment">// 兼容</span></span><br><span class="line"><span class="comment">// 枚举之间不兼容</span></span><br><span class="line"><span class="keyword">let</span> color: Color.Red = Fruit.Apple</span><br></pre></td></tr></table></figure>

<h4 id="类兼容性"><a href="#类兼容性" class="headerlink" title="类兼容性"></a>类兼容性</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类兼容性（与接口类似）</span></span><br><span class="line"><span class="comment">// 静态成员与构造函数不参与比较</span></span><br><span class="line"><span class="comment">// 拥有相同实例，实例间兼容</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>)</span> &#123;&#125;</span><br><span class="line">  id: <span class="built_in">number</span> = <span class="number">1</span></span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> s = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">p: <span class="built_in">number</span></span>)</span> &#123;&#125;</span><br><span class="line">  id: <span class="built_in">number</span> = <span class="number">2</span></span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aa = <span class="keyword">new</span> A(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> ab = <span class="keyword">new</span> B(<span class="number">1</span>)</span><br><span class="line">aa = ab</span><br><span class="line">ab = aa</span><br><span class="line"><span class="comment">// 含有私有成员，只有父类子类兼容</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> ad = <span class="keyword">new</span> D(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">aa = ac</span><br><span class="line">ac = aa</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="泛型兼容性"><a href="#泛型兼容性" class="headerlink" title="泛型兼容性"></a>泛型兼容性</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型兼容性</span></span><br><span class="line"><span class="keyword">interface</span> Empty&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> o1: Empty&lt;<span class="built_in">number</span>&gt; = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> o2: Empty&lt;<span class="built_in">string</span>&gt; = &#123;&#125;</span><br><span class="line">o1 = o2 <span class="comment">// 因为没有任何成员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Empty2&lt;T&gt; &#123;</span><br><span class="line">  value: T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> o3: Empty2&lt;<span class="built_in">number</span>&gt; = &#123;<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> o4: Empty2&lt;<span class="built_in">string</span>&gt; = &#123;<span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line">o3 = o4 <span class="comment">// 不兼容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型函数</span></span><br><span class="line"><span class="keyword">let</span> loga = &lt;T&gt;(x: T): <span class="function"><span class="params">T</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> logb = &lt;U&gt;(y: U): <span class="function"><span class="params">U</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line">loga = logb</span><br></pre></td></tr></table></figure>



<h4 id="口诀"><a href="#口诀" class="headerlink" title="口诀"></a>口诀</h4><ul>
<li>结构之间兼容：成员少的兼容成员多的</li>
<li>函数之间兼容：参数多的兼容参数少的</li>
</ul>
<hr>
<h3 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Type &#123;Strong, Week&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Java</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">helloJava</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello Java&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaScript</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">helloJavaScript</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello JavScript&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLanguage</span>(<span class="params"><span class="keyword">type</span>: Type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lang = <span class="keyword">type</span> === Type.Strong ? <span class="keyword">new</span> Java() : <span class="keyword">new</span> JavaScript()</span><br><span class="line">  <span class="keyword">if</span>(<span class="string">&#x27;helloJava&#x27;</span> <span class="keyword">in</span> lang) &#123;</span><br><span class="line">    lang.helloJava()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lang.helloJavaScript()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> lang</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getLanguage(Type.Strong)</span><br></pre></td></tr></table></figure>

<p>TypeScript 能够在特定区块中保证变量属于某确定类型</p>
<p>可以在此区块中放心地引用此类型的属性，或者调用此类型的方法</p>
<h4 id="四种创建区块的方法"><a href="#四种创建区块的方法" class="headerlink" title="四种创建区块的方法"></a>四种创建区块的方法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instanceof</span></span><br><span class="line"><span class="keyword">if</span>(lang <span class="keyword">instanceof</span> Java) &#123;</span><br><span class="line">  lang.helloJava()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  lang.helloJavaScript()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Java</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">helloJava</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello Java&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  java: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaScript</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">helloJavaScript</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello JavScript&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  javascript: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLanguage</span>(<span class="params"><span class="keyword">type</span>: Type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lang = <span class="keyword">type</span> === Type.Strong ? <span class="keyword">new</span> Java() : <span class="keyword">new</span> JavaScript()</span><br><span class="line">  <span class="comment">// in</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="string">&#x27;java&#x27;</span> <span class="keyword">in</span> lang) &#123;</span><br><span class="line">    lang.helloJava()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lang.helloJavaScript()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> lang</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typeof</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLanguage</span>(<span class="params"><span class="keyword">type</span>: Type, x: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// typeof</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">    x.length</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    x.toFixed(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类型保护函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isJava</span>(<span class="params">lang: Java | JavaScript</span>): <span class="title">lang</span> <span class="title">is</span> <span class="title">Java</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (lang <span class="keyword">as</span> Java).helloJava !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLanguage</span>(<span class="params"><span class="keyword">type</span>: Type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lang = <span class="keyword">type</span> === Type.Strong ? <span class="keyword">new</span> Java() : <span class="keyword">new</span> JavaScript()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(isJava(lang)) &#123;</span><br><span class="line">    lang.helloJava()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lang.helloJavaScript()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> lang</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getLanguage(Type.Strong)</span><br></pre></td></tr></table></figure>

<h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><p>高级类型就是指 TS 为了保证语言的灵活性，所引入的一些语言特性（类似语法糖？）</p>
<h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>将多个类型合并成一个类型，新的类型将具有所有类型的特性，交叉类型特别适合对象混入的场景</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> DogInterface &#123;</span><br><span class="line">  run(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> CatInterface &#123;</span><br><span class="line">  jump(): <span class="built_in">void</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> pet: DogInterface &amp; CatInterface = &#123;</span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">jump</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="title">implements</span> <span class="title">DogInterface</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="title">implements</span> <span class="title">CatInterface</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">jump</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">enum</span> Master &#123; Boy, Girl &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPet</span>(<span class="params">master: Master</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pet = master === Master.Boy ? <span class="keyword">new</span> Dog() : <span class="keyword">new</span> Cat</span><br><span class="line">  pet.eat() <span class="comment">// 未确定情况下只能访问交集</span></span><br><span class="line">  <span class="keyword">return</span> pet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到这个就是交叉类型（所有类型的并集）：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pet: DogInterface &amp; CatInterface = &#123;</span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">jump</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>明确概念：声明的类型并不确定，可以为其中的一个</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span> | <span class="built_in">string</span> = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// 限定取值</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="keyword">let</span> c: <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPet</span>(<span class="params">master: Master</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pet = master === Master.Boy ? <span class="keyword">new</span> Dog() : <span class="keyword">new</span> Cat</span><br><span class="line">  pet.eat() <span class="comment">// 未确定情况下只能访问交集</span></span><br><span class="line">  <span class="keyword">return</span> pet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可区分的联合类型"><a href="#可区分的联合类型" class="headerlink" title="可区分的联合类型"></a>可区分的联合类型</h4><p>这种模式本质上讲，是一种结合了联合类型与自身变量的类型保护方法。一个类型如果是多个类型的联合类型，且每个类型之间有一个公共属性，我们就可以借助这个公共属性，创建不同的类型保护区块。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">  kind: <span class="string">&#x27;square&#x27;</span>,</span><br><span class="line">  size: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Rectangle &#123;</span><br><span class="line">  kind: <span class="string">&#x27;rectangle&#x27;</span>,</span><br><span class="line">  width: <span class="built_in">number</span>,</span><br><span class="line">  height: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shape = Square | Rectangle</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(s.kind) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;square&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> s.size * s.size</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;rectangle&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> s.width * s.height</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想要加新的 <code>Shape</code>，就可能有一些隐患：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">  kind: <span class="string">&#x27;square&#x27;</span>,</span><br><span class="line">  size: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Rectangle &#123;</span><br><span class="line">  kind: <span class="string">&#x27;rectangle&#x27;</span>,</span><br><span class="line">  width: <span class="built_in">number</span>,</span><br><span class="line">  height: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">  kind: <span class="string">&#x27;circle&#x27;</span>,</span><br><span class="line">  r: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shape = Square | Rectangle | Circle</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(s.kind) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;square&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> s.size * s.size</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;rectangle&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> s.width * s.height</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以打印：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(area(&#123;<span class="attr">kind</span>: <span class="string">&#x27;circle&#x27;</span>, <span class="attr">r</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>返回一个 <code>undefined</code>，这样没有约束是不好的，我们修改一下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：指定返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>):<span class="title">number</span> </span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法2：使用 never 类型</span></span><br><span class="line"><span class="keyword">type</span> Shape = Square | Rectangle | Circle</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(s.kind) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;square&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> s.size * s.size</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;rectangle&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> s.width * s.height</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;circle&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> s.r * s.r * <span class="number">3.14</span> / <span class="number">2</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> (<span class="function">(<span class="params">e: <span class="built_in">never</span></span>) =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(e) &#125;)(s)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p>常见场景：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽取值，形成数组：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValues</span>(<span class="params">obj: <span class="built_in">any</span>, keys: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> keys.map(<span class="function"><span class="params">key</span> =&gt;</span> obj[key])</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getValues(obj, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])) <span class="comment">// [1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(getValues(obj, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])) <span class="comment">// [undefined, undefined]</span></span><br></pre></td></tr></table></figure>

<p>但是编译器并没有报错，我们使用索引类型进行约束，我们先要了解几个概念</p>
<ul>
<li><p>索引类型的查询操作符 <code>keyof T</code>：表示类型 T 的所有公共属性的自变量的联合类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Obj &#123;</span><br><span class="line">	a: <span class="built_in">number</span>,</span><br><span class="line">	b: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> key: keyof Obj <span class="comment">// &#x27;a&#x27; | &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>索引访问操作符 <code>T[K]</code>：表示对象 T 的属性 K 所代表的类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: Obj[<span class="string">&#x27;a&#x27;</span>] <span class="comment">// number</span></span><br></pre></td></tr></table></figure></li>
<li><p>泛型继承约束 <code>T extends U</code>：泛型变量通过集成某个类型，获得某些属性</p>
</li>
</ul>
<p>我们现在来改造函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValues</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keysof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, keys: K[]</span>): <span class="title">T</span>[<span class="title">K</span>][] </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> keys.map(<span class="function"><span class="params">key</span> =&gt;</span> obj[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候 TS 类型检查就起作用了</p>
<p>索引类型能实现对对象属性的查询访问，然后泛型约束，就能建立对象、对象属性及属性值之间的约束关系</p>
<h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><p>通过映射类型可以从旧的类型生成新的类型，把一个类型中的所有属性变为只读</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Obj &#123;</span><br><span class="line">	a: <span class="built_in">string</span>,</span><br><span class="line">	b: <span class="built_in">number</span>,</span><br><span class="line">	c: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过 TS 内置的泛型接口转换</span></span><br><span class="line"><span class="keyword">type</span> ReadonlyObj = Readonly&lt;Obj&gt;</span><br></pre></td></tr></table></figure>

<p>这是如何实现的呢？我们跳转到实现方法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>索引签名是 <code>P in keyof T</code>：执行了一次遍历操作，P 依次绑定到 T 的属性上</p>
<p>索引签名返回值是索引访问操作符 <code>T[P]</code>：属性 P 所指定的类型</p>
<p>最后加上 readonly，就将所有属性变为了只读</p>
<p>把一个接口的所有属性变为可选的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PartialObj = Partial&lt;Obj&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>pick 映射类型，可以抽取 obj 类型的子集</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PickObj = Pick&lt;Obj, <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上三种类型，官方称之为同态，也就是说它们不会引入新的类型</p>
<p>创建新的属性的映射类型：Record</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RecordObj = Record&lt;<span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>, Obj&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h3><p>条件类型是一种由条件表达式所决定的类型，形式如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U ？ X ： Y</span><br></pre></td></tr></table></figure>

<p>如果类型 T 可以赋值给类型 U，那么结果类型就是 X 类型，条件类型使类型具有了不唯一性，同样的增加了类型的灵活性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeName&lt;T&gt; = </span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="string">&#x27;string&#x27;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">&#x27;number&#x27;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="string">&#x27;boolean&#x27;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="literal">undefined</span> ? <span class="string">&#x27;undefined&#x27;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">Function</span> ? <span class="string">&#x27;function&#x27;</span> :</span><br><span class="line">  <span class="string">&#x27;object&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这是一种条件类型的嵌套，依次判断 T 的类型，然后返回不同字符串</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = TypeName&lt;<span class="built_in">string</span>&gt;    <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> t2 = TypeName&lt;<span class="built_in">string</span>[]&gt;  <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<p>介绍一种分布式条件类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(A | B) <span class="keyword">extends</span> U ？ X ： Y</span><br></pre></td></tr></table></figure>

<p>这时候结果类型会变成多个条件类型的联合类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（A <span class="keyword">extends</span> U ？ X ： Y） | (B <span class="keyword">extends</span> U ？ X ： Y）</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type t3 &#x3D; TypeName&lt;string | string[]&gt;</span><br></pre></td></tr></table></figure>

<p>利用这个特性可以帮助我们完成类型的过滤</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Diff&lt;T, U&gt; &#x3D; T extends U ? never : T</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type t4 &#x3D; Diff&lt;&#39;a&#39; | &#39;b&#39; | &#39;c&#39;, &#39;a&#39; | &#39;e&#39;&gt;</span><br></pre></td></tr></table></figure>

<p>最终 t4 的类型就变成了 b 和 c 的联合类型</p>
<p>继续扩展：从类型中去除不需要的类型，undefined 与 null：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NotNull&lt;T&gt; = Diff&lt;T, <span class="literal">undefined</span> | <span class="literal">null</span>&gt;</span><br><span class="line"><span class="keyword">type</span> TS = NotNull&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">undefined</span> | <span class="literal">null</span>&gt;</span><br></pre></td></tr></table></figure>

<p>以上两个类型，官方已经实现了：</p>
<ol>
<li>Diff：<code>Exclude&lt;T, U&gt;</code>过滤</li>
<li>NoutNull：<code>NonNulable&lt;T&gt;</code></li>
<li>Diff 相反作用<code>Extract&lt;T, U&gt;</code>，不是过滤而是抽取（交集）</li>
</ol>
<p>介绍一种与以上实现不太一样的类型 <code>ReturnType&lt;T&gt;</code>，获得函数返回值的类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t7 = ReturnType&lt;<span class="function">() =&gt;</span> <span class="built_in">string</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; infer R ? R : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<p><code>infer</code> 关键字：代推断，延迟推断</p>

  </div>
  <div>
    <a href="https://github.com/Mcguffen/mcguffen.github.io/edit/myblog/source/_posts/docs/frontEnd/TypeScript/ts01.md"target="_blank">编辑</a>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/Mcguffen?tab=repositories">项目</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">类型基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%B1%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">强类型语言与弱类型语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是强类型语言？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%B1%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">什么是弱类型语言？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.1.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">1.2.</span> <span class="toc-text">静态类型语言与动态类型语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaScript-%E4%B8%8E-C-%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.1.</span> <span class="toc-text">JavaScript 与 C++ 对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.2.</span> <span class="toc-text">对比总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">其他定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">1.3.</span> <span class="toc-text">小结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B%E8%B1%A1%E9%99%90"><span class="toc-number">1.3.1.</span> <span class="toc-text">语言类型象限</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-TypeScript-%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.1.</span> <span class="toc-text">创建 TypeScript 项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7"><span class="toc-number">2.1.1.</span> <span class="toc-text">配置构建工具</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-webpack-base-config-js"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">公共环境配置 webpack.base.config.js</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-webpack-dev-config-js"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">开发环境 webpack.dev.config.js</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83-webpack-pro-config-js"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">生产环境 webpack.pro.config.js</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6-webpack-config-js"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">入口文件 webpack.config.js</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9-NPM-%E8%84%9A%E6%9C%AC"><span class="toc-number">2.1.2.</span> <span class="toc-text">修改 NPM 脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%84%9A%E6%9C%AC"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">开发环境脚本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E8%84%9A%E6%9C%AC"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">生产环境脚本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-1"><span class="toc-number">2.2.</span> <span class="toc-text">基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.2.1.</span> <span class="toc-text">类型注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">基本数据类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.</span> <span class="toc-text">类与接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.</span> <span class="toc-text">对象类型接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E7%B4%A2%E5%BC%95%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.1.</span> <span class="toc-text">可索引接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.2.</span> <span class="toc-text">函数类型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.3.</span> <span class="toc-text">混合类型接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.</span> <span class="toc-text">函数定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">可选参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">5.3.</span> <span class="toc-text">参数默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">剩余参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">5.5.</span> <span class="toc-text">函数重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">6.1.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">6.2.</span> <span class="toc-text">成员修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#public"><span class="toc-number">6.2.1.</span> <span class="toc-text">public</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#private"><span class="toc-number">6.2.2.</span> <span class="toc-text">private</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#protected"><span class="toc-number">6.2.3.</span> <span class="toc-text">protected</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readonly"><span class="toc-number">6.2.4.</span> <span class="toc-text">readonly</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">6.2.5.</span> <span class="toc-text">构造函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static"><span class="toc-number">6.2.6.</span> <span class="toc-text">static</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">6.3.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">6.4.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.5.</span> <span class="toc-text">this 类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.</span> <span class="toc-text">接口与类的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.1.</span> <span class="toc-text">类类型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">7.2.</span> <span class="toc-text">接口的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E7%B1%BB"><span class="toc-number">7.3.</span> <span class="toc-text">接口继承类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3"><span class="toc-number">7.4.</span> <span class="toc-text">图解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">8.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0%E4%B8%8E%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.2.</span> <span class="toc-text">泛型函数与泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">8.3.</span> <span class="toc-text">泛型类与泛型约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84"><span class="toc-number">8.4.</span> <span class="toc-text">好处</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TypeScript-%E8%BF%9B%E9%98%B6"><span class="toc-number"></span> <span class="toc-text">TypeScript 进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">类型检查机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">1.1.</span> <span class="toc-text">类型推断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">1.1.1.</span> <span class="toc-text">基础类型推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">1.1.2.</span> <span class="toc-text">最佳通用类型推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">1.1.3.</span> <span class="toc-text">上下文类型推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">1.1.4.</span> <span class="toc-text">类型断言</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">类型兼容性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">什么是兼容性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%97%B4%E5%85%BC%E5%AE%B9"><span class="toc-number">1.2.2.</span> <span class="toc-text">接口间兼容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%97%B4%E5%85%BC%E5%AE%B9"><span class="toc-number">1.2.3.</span> <span class="toc-text">函数间兼容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">1.2.4.</span> <span class="toc-text">枚举兼容性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">1.2.5.</span> <span class="toc-text">类兼容性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">1.2.6.</span> <span class="toc-text">泛型兼容性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A3%E8%AF%80"><span class="toc-number">1.2.7.</span> <span class="toc-text">口诀</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.3.</span> <span class="toc-text">类型保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E5%88%9B%E5%BB%BA%E5%8C%BA%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">四种创建区块的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">高级类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">交叉类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">联合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8C%BA%E5%88%86%E7%9A%84%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">可区分的联合类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">索引类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">映射类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.5.</span> <span class="toc-text">条件类型</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/&text=TypeScript 整理手册"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/&title=TypeScript 整理手册"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/&is_video=false&description=TypeScript 整理手册"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=TypeScript 整理手册&body=Check out this article: http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/&title=TypeScript 整理手册"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/&title=TypeScript 整理手册"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/&title=TypeScript 整理手册"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/&title=TypeScript 整理手册"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/&name=TypeScript 整理手册&description=&lt;p&gt;JS 是一门动态弱类型语言，与之对应，自然有静态类型语言和强类型语言。如何区分它们，是在学习一门计算机语言之前首先要搞清楚的问题，理解了这些概念，你就会明白为什么有语言鄙视链，也会对 TS 的诞生的原因有一定的认识。&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2020/06/29/docs/frontEnd/TypeScript/ts01/&t=TypeScript 整理手册"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2021
    Hi! I am yang.
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/Mcguffen?tab=repositories">项目</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
